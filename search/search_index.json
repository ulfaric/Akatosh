{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Akatosh","text":"<p> <code>Akatosh</code> is a light-weighted disceret event simulation library. Unlike popular library <code>Simpy</code> which is progress-oriented and you have to write generator function for simulated events or events interaction, `Akatosh` is fully object-oriented that events are encapsulated as `InstantEvent`/`ContinousEvent` with states, priority and a life-cycle. The actual impact of events are simply regular python functions. You could create events all at once, or create event within event. In addition, `Akatosh` is async which means event that are happening at the same simulated time will be executed simultaneously for real, unless they have different priority. </p> <p> <code>Akatosh</code> also support <code>Resource</code>, provide all functionalities as it is in <code>Simpy</code> with extra utilities for telemetries collection and interaction with <code>Entity</code>. The <code>Entity</code> is unique to <code>Akatosh</code> which represents a abstract entity with a life-cycle, for example a follower. The <code>Entity</code> supports utility functions to interact with <code>Resource</code> and automatically releases all its occupied resources upon termination. </p> <p> You probably already noticed that <code>Akatosh</code> is the name of \"Dragon God of Time\" in elder scroll serie, therefore the singleton class <code>Mundus</code> is the core of the simulation. The <code>Mundus</code> will schedule the events, move forward time and engage async execution. </p> <p>To use <code>Akatosh</code>: <pre><code>pip install -U Akatosh\n</code></pre></p> <p>A basic example is showing below, for more information please look at Examples and API Reference</p> <pre><code>import logging\n\nfrom Akatosh import event, Mundus\n\n# create two instant event at simulation time 1.0 and 5.0\n@event(at=5)\ndef hellow_world_again():\n    print(f\"{Mundus.now}:\\tHello World! Again!\")\n\n\n@event(at=1)\ndef hellow_world():\n    print(f\"{Mundus.now}:\\tHello World!\")\n\n# enable debug message\nMundus.set_logger(logging.DEBUG)\n\n# run simulation for 6s\nMundus.simulate(6)\n</code></pre>"},{"location":"api/continuous_event/","title":"ContinuousEvent","text":"<p>             Bases: <code>Event</code></p> Source code in <code>Akatosh\\event.py</code> <pre><code>class ContinuousEvent(Event):\n    def __init__(\n        self,\n        at: int | float | Callable[..., int] | Callable[..., float],\n        interval: int | float | Callable[..., int] | Callable[..., float],\n        duration: int | float | Callable[..., int] | Callable[..., float],\n        precursor: Event | List[Event] | None = None,\n        action: Callable[..., Any] | None = None,\n        priority: int | float | Callable[..., int] | Callable[..., float] = 0,\n        label: str | None = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Continous event is an event that happens at a specific time and happens multiple times for a specific duration.\n\n        Args:\n            at (int | float | Callable[...,int] | Callable[...,float]): when the event happens.\n            interval (int | float | Callable[...,int] | Callable[...,float]): the interval between each action repeat.\n            duration (int | float | Callable[...,int] | Callable[...,float]): the duration of the event.\n            precursor (Event | List[Event] | None, optional): the precursor events, can be both instant events or continous events. Defaults to None.\n            action (Callable[..., Any] | None, optional): the actual action of the event. Defaults to None.\n            priority (int | float | Callable[...,int] | Callable[...,float], optional): the priority of the event. Defaults to 0.\n            label (str | None, optional): short description of the event.. Defaults to None.\n        \"\"\"\n        super().__init__(\n            at=at,\n            precursor=precursor,\n            action=action,\n            priority=priority,\n            label=label,\n            **kwargs,\n        )\n\n        self._interval = interval\n        if callable(duration):\n            self._duration = round(duration(), Mundus.resolution)\n        else:\n            self._duration = round(duration, Mundus.resolution)\n        self._till = self.at + self.duration\n        self._sub_events: List[InstantEvent] = list()\n\n    async def _perform(self):\n        \"\"\"Perform the action of the event. Compare to instant event, continous event will perform the action multiple times.\"\"\"\n        if self.action:\n            self.action()\n            if callable(self.interval):\n                self._at = round(self.interval() + Mundus.now, Mundus.resolution)\n            else:\n                self._at = round(self.interval + Mundus.now, Mundus.resolution)\n            if self.at &lt;= self.till:\n                logger.debug(f\"Event {self.label} next step is at {self.at}.\")\n                Mundus.future_events.append(self)\n                Mundus.current_events.remove(self)\n            else:\n                self.end()\n\n    def activate(self, force: bool = False):\n        if Mundus.now &gt; self.till:\n            logger.debug(f\"Event {self.label} has passed due time.\")\n            return\n        else:\n            super().activate(force)\n\n    @property\n    def interval(self) -&gt; int | float | Callable[..., Any]:\n        \"\"\"Return the interval between each action repeat.\"\"\"\n        return self._interval\n\n    @property\n    def duration(self) -&gt; int | float:\n        \"\"\"Return the duration of the event.\"\"\"\n        return self._duration\n\n    @property\n    def till(self) -&gt; int | float:\n        \"\"\"Return the time when the event ends.\"\"\"\n        return self._till\n\n    @property\n    def sub_events(self) -&gt; List[InstantEvent]:\n        \"\"\"Return the sub events of the continous event.\"\"\"\n        return self._sub_events\n</code></pre>"},{"location":"api/continuous_event/#Akatosh.event.ContinuousEvent.duration","title":"<code>duration: int | float</code>  <code>property</code>","text":"<p>Return the duration of the event.</p>"},{"location":"api/continuous_event/#Akatosh.event.ContinuousEvent.interval","title":"<code>interval: int | float | Callable[..., Any]</code>  <code>property</code>","text":"<p>Return the interval between each action repeat.</p>"},{"location":"api/continuous_event/#Akatosh.event.ContinuousEvent.sub_events","title":"<code>sub_events: List[InstantEvent]</code>  <code>property</code>","text":"<p>Return the sub events of the continous event.</p>"},{"location":"api/continuous_event/#Akatosh.event.ContinuousEvent.till","title":"<code>till: int | float</code>  <code>property</code>","text":"<p>Return the time when the event ends.</p>"},{"location":"api/continuous_event/#Akatosh.event.ContinuousEvent.__init__","title":"<code>__init__(at, interval, duration, precursor=None, action=None, priority=0, label=None, **kwargs)</code>","text":"<p>Continous event is an event that happens at a specific time and happens multiple times for a specific duration.</p> <p>Parameters:</p> Name Type Description Default <code>at</code> <code>int | float | Callable[..., int] | Callable[..., float]</code> <p>when the event happens.</p> required <code>interval</code> <code>int | float | Callable[..., int] | Callable[..., float]</code> <p>the interval between each action repeat.</p> required <code>duration</code> <code>int | float | Callable[..., int] | Callable[..., float]</code> <p>the duration of the event.</p> required <code>precursor</code> <code>Event | List[Event] | None</code> <p>the precursor events, can be both instant events or continous events. Defaults to None.</p> <code>None</code> <code>action</code> <code>Callable[..., Any] | None</code> <p>the actual action of the event. Defaults to None.</p> <code>None</code> <code>priority</code> <code>int | float | Callable[..., int] | Callable[..., float]</code> <p>the priority of the event. Defaults to 0.</p> <code>0</code> <code>label</code> <code>str | None</code> <p>short description of the event.. Defaults to None.</p> <code>None</code> Source code in <code>Akatosh\\event.py</code> <pre><code>def __init__(\n    self,\n    at: int | float | Callable[..., int] | Callable[..., float],\n    interval: int | float | Callable[..., int] | Callable[..., float],\n    duration: int | float | Callable[..., int] | Callable[..., float],\n    precursor: Event | List[Event] | None = None,\n    action: Callable[..., Any] | None = None,\n    priority: int | float | Callable[..., int] | Callable[..., float] = 0,\n    label: str | None = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Continous event is an event that happens at a specific time and happens multiple times for a specific duration.\n\n    Args:\n        at (int | float | Callable[...,int] | Callable[...,float]): when the event happens.\n        interval (int | float | Callable[...,int] | Callable[...,float]): the interval between each action repeat.\n        duration (int | float | Callable[...,int] | Callable[...,float]): the duration of the event.\n        precursor (Event | List[Event] | None, optional): the precursor events, can be both instant events or continous events. Defaults to None.\n        action (Callable[..., Any] | None, optional): the actual action of the event. Defaults to None.\n        priority (int | float | Callable[...,int] | Callable[...,float], optional): the priority of the event. Defaults to 0.\n        label (str | None, optional): short description of the event.. Defaults to None.\n    \"\"\"\n    super().__init__(\n        at=at,\n        precursor=precursor,\n        action=action,\n        priority=priority,\n        label=label,\n        **kwargs,\n    )\n\n    self._interval = interval\n    if callable(duration):\n        self._duration = round(duration(), Mundus.resolution)\n    else:\n        self._duration = round(duration, Mundus.resolution)\n    self._till = self.at + self.duration\n    self._sub_events: List[InstantEvent] = list()\n</code></pre>"},{"location":"api/entity/","title":"Entity","text":"Source code in <code>Akatosh\\entity.py</code> <pre><code>class Entity:\n    def __init__(\n        self,\n        label: str | None = None,\n        create_at: int\n        | float\n        | Callable[..., int]\n        | Callable[..., float]\n        | None = None,\n        terminate_at: int\n        | float\n        | Callable[..., int]\n        | Callable[..., float]\n        | None = None,\n        precursor: Entity | List[Entity] | None = None,\n    ) -&gt; None:\n        \"\"\"Create a entity.\n\n        Args:\n            label (str | None, optional): short description of the entity. Defaults to None.\n            create_at (int | float | Callable | None, optional): when the life cycle of this entity should start. Defaults to 0, then must call create() method manually.\n            terminate_at (int | float | Callable | None, optional): when the life cycle of this entity should end. Defaults to inf, then must call terminate() method manually.\n        \"\"\"\n        self._id = uuid4().int\n        self._label = label\n        self._state: List[str] = list()\n        self._occupied_resources: List[Resource] = list()\n        self._registered_lists: List[EntityList] = list()\n        self._creation: InstantEvent = None  # type: ignore\n        self._termination: InstantEvent = None  # type: ignore\n        self._destruction: InstantEvent = None  # type: ignore\n        self._events: List[Event] = list()\n\n        # assign precursor and followers\n        if isinstance(precursor, list):\n            self._precursor = precursor\n        elif precursor is None:\n            self._precursor = []\n        else:\n            self._precursor = [precursor]\n        self._followers: List[Entity] = []\n        for event in self.precursor:\n            event._followers.append(self)\n\n        # assign create_at and terminate_at\n        if create_at is not None:\n            if callable(create_at):\n                self._to_be_created_at = round(create_at(), Mundus.resolution)\n            else:\n                self._to_be_created_at = round(create_at, Mundus.resolution)\n        else:\n            self._to_be_created_at = 0\n        self._created_at = float()\n\n        if terminate_at is not None:\n            if callable(terminate_at):\n                self._to_be_terminated_at = round(terminate_at(), Mundus.resolution)\n            else:\n                self._to_be_terminated_at = round(terminate_at, Mundus.resolution)\n        else:\n            self._to_be_terminated_at = inf\n        self._terminated_at = float()\n\n        self._to_be_destoried = float()\n        self._destoried_at = float()\n\n        # create the entity if no precursor\n        if create_at is not None and len(self.precursor) == 0:\n            self.create(self.to_be_created_at)\n\n    def create(self, at: int | float, force=False) -&gt; None:\n        \"\"\"The creation of the entity.\"\"\"\n        if self.created:\n            logger.warning(f\"Entity {self.label} is already created.\")\n            return\n\n        # check if the entity is already over due\n        if self.terminated or self.destroied:\n            logger.debug(f\"Entity {self.label} is already terminated or destoried.\")\n            return\n\n        # call back function for creation\n        def _create():\n            if self.created:\n                return\n            self._created_at = Mundus.now\n            self._state.append(State.CREATED)\n            self.on_creation()\n            logger.debug(f\"Entity {self.label} created at {at}\")\n\n        self._to_be_created_at = max([at, self.to_be_created_at])\n\n        # force creation if force is True, regardless of the precursor and the time\n        if force:\n            self._creation = InstantEvent(\n                at=self.to_be_created_at,\n                action=_create,\n                label=f\"Creation of {self.label}\",\n                priority=-2,\n            )\n            if self.to_be_terminated_at != inf:\n                self.terminate(self.to_be_terminated_at)\n        else:\n            # check if all precursors are terminated, if so, create the entity\n            if len(self.precursor) != 0:\n                if all(p.terminated for p in self.precursor):\n                    self._creation = InstantEvent(\n                        at=self.to_be_created_at,\n                        action=_create,\n                        label=f\"Creation of {self.label}\",\n                        priority=-2,\n                    )\n                    if self.to_be_terminated_at != inf:\n                        self.terminate(self.to_be_terminated_at)\n                else:\n                    logger.debug(f\"Entity {self.label} is not created due to unfinished precursors.\")\n            # no precursor, create the entity\n            else:\n                self._creation = InstantEvent(\n                    at=self.to_be_created_at,\n                    action=_create,\n                    label=f\"Creation of {self.label}\",\n                    priority=-2,\n                )\n                if self.to_be_terminated_at != inf:\n                    self.terminate(self.to_be_terminated_at)\n\n    @abstractmethod\n    def on_creation(self):\n        \"\"\"Callback function upon creation of the entity\"\"\"\n        pass\n\n    def terminate(self, at: int | float) -&gt; None:\n        \"\"\"The termination of the entity. This will release all occupied resource, remove the entity from all entity lists, and cancel all unfinished events.\"\"\"\n\n        if self.terminated or self.destroied:\n            logger.warning(f\"Entity {self.label} is already terminated or destoried.\")\n            return\n\n        def _terminate():\n            if self.terminated or self.destroied:\n                return\n            if not self.created:\n                logger.warning(f\"Entity {self.label} is not created yet, so considered destoried.\")\n                self.destory(Mundus.now)\n                return\n            self._terminated_at = Mundus.now\n            self._state.append(State.TERMINATED)\n            self.release_resources()\n            self.unregister_from_lists()\n            self.cancel_unfinished_events()\n            self.on_termination()\n            logger.debug(f\"Entity {self.label} terminated at {Mundus.now}\")\n            for entity in self._followers:\n                entity.create(Mundus.now)\n\n        # check if a later termination is scheduled\n        # if self._to_be_terminated_at &gt; at:\n        #     self._to_be_terminated_at = at\n\n        # if self._termination is not None:\n        #     self._termination.cancel()\n        if self._termination is not None:\n            if self._termination.at &gt; at:\n                self._termination.cancel()\n                self._to_be_terminated_at = at\n            else:\n                logger.debug(f\"Entity {self.label} is already scheduled to be terminated at {self._termination.at}.\")\n                return\n        else:\n            self._to_be_terminated_at = at\n\n        self._termination = InstantEvent(\n            at=self.to_be_terminated_at,\n            action=_terminate,\n            label=f\"Termination of {self.label}\",\n            priority=-2,\n        )\n\n    @abstractmethod\n    def on_termination(self):\n        \"\"\"Callback function upon termination of the entity\"\"\"\n        pass\n\n    def destory(self, at: int | float) -&gt; None:\n        \"\"\"The Destruction of the entity. This will release all occupied resource, remove the entity from all entity lists, and cancel all unfinished events. This will not trigger the creation of followers.\"\"\"\n\n        if self.terminated or self.destroied:\n            logger.warning(f\"Entity {self.label} is already destroied.\")\n            return\n\n        def _destroy():\n            if self.terminated or self.destroied:\n                return\n            self._terminated_at = Mundus.now\n            self._state.append(State.TERMINATED)\n            self._state.append(State.DESTROIED)\n            self.release_resources()\n            self.unregister_from_lists()\n            self.cancel_unfinished_events()\n            self.on_destruction()\n            logger.debug(f\"Entity {self.label} destoried at {Mundus.now}\")\n\n        # if self._destruction is not None:\n        #     self._destruction.cancel()\n\n        # if self._termination is not None and self.to_be_terminated_at &lt; at:\n        #     return\n\n        if self._termination is not None:\n            if self._termination.at &lt; at:\n                logger.debug(f\"Entity {self.label} is already scheduled to be terminated at {self._termination.at}, so this destruction is ignored\")\n                return\n\n        if self._destruction is not None:\n            if self._destruction.at &lt; at:\n                logger.debug(f\"Entity {self.label} is already scheduled to be destoried at {self._destruction.at}, so this destruction is ignored\")\n                return\n        else:\n            self._to_be_destoried = at\n\n        self._destruction = InstantEvent(\n            at=self.to_be_terminated_at if self.to_be_terminated_at &lt; at else at,\n            action=_destroy,\n            label=f\"Destruction of {self.label}\",\n            priority=-2,\n        )\n\n    @abstractmethod\n    def on_destruction(self):\n        \"\"\"Callback function upon destruction of the entity\"\"\"\n        pass\n\n    def get(\n        self, resource: Resource, amount: int | float | Callable | None = None\n    ) -&gt; None:\n        \"\"\"Consume certain amout from a resource. if no amount is specified, consume all.\"\"\"\n\n        if not self.created:\n            raise RuntimeError(\n                f\"Entity {self} is not created yet, can not interact with any resource.\"\n            )\n\n        if self.terminated:\n            raise RuntimeError(\n                f\"Entity {self} is already terminated, can not interact with any resource.\"\n            )\n\n        if amount:\n            if callable(amount):\n                resource.distribute(self, amount())\n                if resource not in self.ocupied_resources:\n                    self.ocupied_resources.append(resource)\n            else:\n                resource.distribute(self, amount)\n                if resource not in self.ocupied_resources:\n                    self.ocupied_resources.append(resource)\n        else:\n            resource.distribute(self, resource.amount)\n\n    def put(\n        self, resource: Resource, amount: int | float | Callable | None = None\n    ) -&gt; None:\n        \"\"\"Return certain amout to a resource. if no amount is specified, return all.\"\"\"\n        if not self.created:\n            raise RuntimeError(\n                f\"Entity {self} is not created yet, can not interact any resource.\"\n            )\n\n        if self.terminated:\n            raise RuntimeError(\n                f\"Entity {self} is already terminated, can not interact any resource.\"\n            )\n\n        if amount:\n            if callable(amount):\n                resource.collect(self, amount())\n                if self not in resource.users:\n                    self.ocupied_resources.remove(resource)\n            else:\n                resource.collect(self, amount)\n                if self not in resource.users:\n                    self.ocupied_resources.remove(resource)\n        else:\n            resource.collect(self)\n\n    def release_resources(self):\n        \"\"\"Release all occupied resources.\"\"\"\n        for res in self.ocupied_resources:\n            res.collect(self)\n\n    def unregister_from_lists(self):\n        \"\"\"Remove this entity from all registered entity lists.\"\"\"\n        for list in self.registered_lists[:]:\n            list.remove(self)\n\n    def cancel_unfinished_events(self):\n        \"\"\"Cancel all unfinished events.\"\"\"\n        for event in self.events:\n            if not event.ended:\n                event.cancel()\n\n    def continuous_event(\n        self,\n        at: int | float | Callable,\n        interval: int | float | Callable,\n        duration: int | float | Callable,\n        precursor: Event | List[Event] | None = None,\n        priority: int | float | Callable = 0,\n        label: str | None = None,\n        **kwargs,\n    ):\n        \"\"\"A decorator for creating continous event engaged by this entity.\n\n        Args:\n            at (int | float | Callable): when the continuous event starts.\n            interval (int | float | Callable): how frequent the event happens.\n            duration (int | float | Callable): the duration of the event.\n            precursor (Event | List[Event] | None, optional): the precursors for this event. Defaults to None.\n            priority (int | float | Callable, optional): the priority for this event. Defaults to 0.\n            label (str | None, optional): short description of the event. Defaults to None.\n        \"\"\"\n\n        def _continous_event(func: Callable):\n            # define a function that validate the entity state first, then create the event\n            def __continous_event():\n                if not self.created:\n                    raise RuntimeError(\n                        f\"Entity {self} is not created yet, can not engage in any event.\"\n                    )\n                if self.terminated:\n                    raise RuntimeError(\n                        f\"Entity {self} is already terminated, can not engage in any event.\"\n                    )\n                self.events.append(\n                    ContinuousEvent(\n                        at=at,\n                        interval=interval,\n                        duration=duration,\n                        precursor=precursor,\n                        action=func,\n                        priority=priority,\n                        label=label,\n                        **kwargs,\n                    )\n                )\n\n            # create the instant event that will validate the entity state first, then create the continuous event\n            InstantEvent(\n                at=at,\n                action=__continous_event,\n                priority=-1,\n                label=f\"Engagement: {label}\",\n            )\n\n        return _continous_event\n\n    def instant_event(\n        self,\n        at: int | float | Callable,\n        precursor: Event | List[Event] | None = None,\n        priority: int | float | Callable = 0,\n        label: str | None = None,\n        **kwargs,\n    ):\n        \"\"\"Decorator for creating instant event.\n\n        Args:\n            at (int | float | Callable): When the event happens.\n            precursor (Event | List[Event] | None, optional): The precursor events. Defaults to None.\n            priority (int | float | Callable, optional): The priority of the event. Defaults to 0.\n            label (str | None, optional): Short description of the event. Defaults to None.\n        \"\"\"\n\n        def _instant_event(func: Callable):\n            def __instant_event():\n                if not self.created:\n                    raise RuntimeError(\n                        f\"Entity {self} is not created yet, can not engage in any event.\"\n                    )\n                if self.terminated:\n                    raise RuntimeError(\n                        f\"Entity {self} is already terminated, can not engage in any event.\"\n                    )\n\n                self.events.append(\n                    InstantEvent(\n                        at=at,\n                        precursor=precursor,\n                        action=func,\n                        priority=priority,\n                        label=label,\n                        **kwargs,\n                    )\n                )\n\n            # create the instant event that will validate the entity state first, then create the event\n            InstantEvent(\n                at=at, action=__instant_event, priority=-1, label=f\"Engagement: {label}\"\n            )\n\n        return _instant_event\n\n    @property\n    def label(self):\n        \"\"\"Return the label of the entity.\"\"\"\n        return self._label\n\n    @property\n    def state(self):\n        \"\"\"Return the state(s) of the entity.\"\"\"\n        return self._state\n\n    @property\n    def created(self):\n        \"\"\"Return True if the entity is created.\"\"\"\n        return State.CREATED in self.state\n\n    @property\n    def to_be_created_at(self):\n        \"\"\"Return the time when the entity should be created.\"\"\"\n        return self._to_be_created_at\n\n    @property\n    def created_at(self):\n        \"\"\"Return the time when the entity is created.\"\"\"\n        return self._created_at\n\n    @property\n    def terminated(self):\n        \"\"\"Return True if the entity is terminated.\"\"\"\n        return State.TERMINATED in self.state and State.DESTROIED not in self.state\n\n    @property\n    def destroied(self):\n        \"\"\"Return True if the entity is destoried.\"\"\"\n        return State.DESTROIED in self.state\n\n    @property\n    def to_be_terminated_at(self):\n        \"\"\"Return the time when the entity should be terminated.\"\"\"\n        return self._to_be_terminated_at\n\n    @property\n    def terminated_at(self):\n        \"\"\"Return the time when the entity is terminated.\"\"\"\n        return self._terminated_at\n\n    @property\n    def destoried_at(self):\n        \"\"\"Return the time when the entity is destoried.\"\"\"\n        return self._destoried_at\n\n    @property\n    def to_be_destoried_at(self):\n        \"\"\"Return the time when the entity should be destoried.\"\"\"\n        return self._to_be_destoried\n\n    @property\n    def ocupied_resources(self):\n        \"\"\"Return the resources occupied by the entity.\"\"\"\n        return self._occupied_resources\n\n    @property\n    def registered_lists(self):\n        \"\"\"Return the entity lists contains the entity.\"\"\"\n        return self._registered_lists\n\n    @property\n    def events(self):\n        \"\"\"Return the events engaged by the entity.\"\"\"\n        return self._events\n\n    @property\n    def precursor(self):\n        \"\"\"Return the precursor(s) of the entity.\"\"\"\n        return self._precursor\n</code></pre>"},{"location":"api/entity/#Akatosh.entity.Entity.created","title":"<code>created</code>  <code>property</code>","text":"<p>Return True if the entity is created.</p>"},{"location":"api/entity/#Akatosh.entity.Entity.created_at","title":"<code>created_at</code>  <code>property</code>","text":"<p>Return the time when the entity is created.</p>"},{"location":"api/entity/#Akatosh.entity.Entity.destoried_at","title":"<code>destoried_at</code>  <code>property</code>","text":"<p>Return the time when the entity is destoried.</p>"},{"location":"api/entity/#Akatosh.entity.Entity.destroied","title":"<code>destroied</code>  <code>property</code>","text":"<p>Return True if the entity is destoried.</p>"},{"location":"api/entity/#Akatosh.entity.Entity.events","title":"<code>events</code>  <code>property</code>","text":"<p>Return the events engaged by the entity.</p>"},{"location":"api/entity/#Akatosh.entity.Entity.label","title":"<code>label</code>  <code>property</code>","text":"<p>Return the label of the entity.</p>"},{"location":"api/entity/#Akatosh.entity.Entity.ocupied_resources","title":"<code>ocupied_resources</code>  <code>property</code>","text":"<p>Return the resources occupied by the entity.</p>"},{"location":"api/entity/#Akatosh.entity.Entity.precursor","title":"<code>precursor</code>  <code>property</code>","text":"<p>Return the precursor(s) of the entity.</p>"},{"location":"api/entity/#Akatosh.entity.Entity.registered_lists","title":"<code>registered_lists</code>  <code>property</code>","text":"<p>Return the entity lists contains the entity.</p>"},{"location":"api/entity/#Akatosh.entity.Entity.state","title":"<code>state</code>  <code>property</code>","text":"<p>Return the state(s) of the entity.</p>"},{"location":"api/entity/#Akatosh.entity.Entity.terminated","title":"<code>terminated</code>  <code>property</code>","text":"<p>Return True if the entity is terminated.</p>"},{"location":"api/entity/#Akatosh.entity.Entity.terminated_at","title":"<code>terminated_at</code>  <code>property</code>","text":"<p>Return the time when the entity is terminated.</p>"},{"location":"api/entity/#Akatosh.entity.Entity.to_be_created_at","title":"<code>to_be_created_at</code>  <code>property</code>","text":"<p>Return the time when the entity should be created.</p>"},{"location":"api/entity/#Akatosh.entity.Entity.to_be_destoried_at","title":"<code>to_be_destoried_at</code>  <code>property</code>","text":"<p>Return the time when the entity should be destoried.</p>"},{"location":"api/entity/#Akatosh.entity.Entity.to_be_terminated_at","title":"<code>to_be_terminated_at</code>  <code>property</code>","text":"<p>Return the time when the entity should be terminated.</p>"},{"location":"api/entity/#Akatosh.entity.Entity.__init__","title":"<code>__init__(label=None, create_at=None, terminate_at=None, precursor=None)</code>","text":"<p>Create a entity.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str | None</code> <p>short description of the entity. Defaults to None.</p> <code>None</code> <code>create_at</code> <code>int | float | Callable | None</code> <p>when the life cycle of this entity should start. Defaults to 0, then must call create() method manually.</p> <code>None</code> <code>terminate_at</code> <code>int | float | Callable | None</code> <p>when the life cycle of this entity should end. Defaults to inf, then must call terminate() method manually.</p> <code>None</code> Source code in <code>Akatosh\\entity.py</code> <pre><code>def __init__(\n    self,\n    label: str | None = None,\n    create_at: int\n    | float\n    | Callable[..., int]\n    | Callable[..., float]\n    | None = None,\n    terminate_at: int\n    | float\n    | Callable[..., int]\n    | Callable[..., float]\n    | None = None,\n    precursor: Entity | List[Entity] | None = None,\n) -&gt; None:\n    \"\"\"Create a entity.\n\n    Args:\n        label (str | None, optional): short description of the entity. Defaults to None.\n        create_at (int | float | Callable | None, optional): when the life cycle of this entity should start. Defaults to 0, then must call create() method manually.\n        terminate_at (int | float | Callable | None, optional): when the life cycle of this entity should end. Defaults to inf, then must call terminate() method manually.\n    \"\"\"\n    self._id = uuid4().int\n    self._label = label\n    self._state: List[str] = list()\n    self._occupied_resources: List[Resource] = list()\n    self._registered_lists: List[EntityList] = list()\n    self._creation: InstantEvent = None  # type: ignore\n    self._termination: InstantEvent = None  # type: ignore\n    self._destruction: InstantEvent = None  # type: ignore\n    self._events: List[Event] = list()\n\n    # assign precursor and followers\n    if isinstance(precursor, list):\n        self._precursor = precursor\n    elif precursor is None:\n        self._precursor = []\n    else:\n        self._precursor = [precursor]\n    self._followers: List[Entity] = []\n    for event in self.precursor:\n        event._followers.append(self)\n\n    # assign create_at and terminate_at\n    if create_at is not None:\n        if callable(create_at):\n            self._to_be_created_at = round(create_at(), Mundus.resolution)\n        else:\n            self._to_be_created_at = round(create_at, Mundus.resolution)\n    else:\n        self._to_be_created_at = 0\n    self._created_at = float()\n\n    if terminate_at is not None:\n        if callable(terminate_at):\n            self._to_be_terminated_at = round(terminate_at(), Mundus.resolution)\n        else:\n            self._to_be_terminated_at = round(terminate_at, Mundus.resolution)\n    else:\n        self._to_be_terminated_at = inf\n    self._terminated_at = float()\n\n    self._to_be_destoried = float()\n    self._destoried_at = float()\n\n    # create the entity if no precursor\n    if create_at is not None and len(self.precursor) == 0:\n        self.create(self.to_be_created_at)\n</code></pre>"},{"location":"api/entity/#Akatosh.entity.Entity.cancel_unfinished_events","title":"<code>cancel_unfinished_events()</code>","text":"<p>Cancel all unfinished events.</p> Source code in <code>Akatosh\\entity.py</code> <pre><code>def cancel_unfinished_events(self):\n    \"\"\"Cancel all unfinished events.\"\"\"\n    for event in self.events:\n        if not event.ended:\n            event.cancel()\n</code></pre>"},{"location":"api/entity/#Akatosh.entity.Entity.continuous_event","title":"<code>continuous_event(at, interval, duration, precursor=None, priority=0, label=None, **kwargs)</code>","text":"<p>A decorator for creating continous event engaged by this entity.</p> <p>Parameters:</p> Name Type Description Default <code>at</code> <code>int | float | Callable</code> <p>when the continuous event starts.</p> required <code>interval</code> <code>int | float | Callable</code> <p>how frequent the event happens.</p> required <code>duration</code> <code>int | float | Callable</code> <p>the duration of the event.</p> required <code>precursor</code> <code>Event | List[Event] | None</code> <p>the precursors for this event. Defaults to None.</p> <code>None</code> <code>priority</code> <code>int | float | Callable</code> <p>the priority for this event. Defaults to 0.</p> <code>0</code> <code>label</code> <code>str | None</code> <p>short description of the event. Defaults to None.</p> <code>None</code> Source code in <code>Akatosh\\entity.py</code> <pre><code>def continuous_event(\n    self,\n    at: int | float | Callable,\n    interval: int | float | Callable,\n    duration: int | float | Callable,\n    precursor: Event | List[Event] | None = None,\n    priority: int | float | Callable = 0,\n    label: str | None = None,\n    **kwargs,\n):\n    \"\"\"A decorator for creating continous event engaged by this entity.\n\n    Args:\n        at (int | float | Callable): when the continuous event starts.\n        interval (int | float | Callable): how frequent the event happens.\n        duration (int | float | Callable): the duration of the event.\n        precursor (Event | List[Event] | None, optional): the precursors for this event. Defaults to None.\n        priority (int | float | Callable, optional): the priority for this event. Defaults to 0.\n        label (str | None, optional): short description of the event. Defaults to None.\n    \"\"\"\n\n    def _continous_event(func: Callable):\n        # define a function that validate the entity state first, then create the event\n        def __continous_event():\n            if not self.created:\n                raise RuntimeError(\n                    f\"Entity {self} is not created yet, can not engage in any event.\"\n                )\n            if self.terminated:\n                raise RuntimeError(\n                    f\"Entity {self} is already terminated, can not engage in any event.\"\n                )\n            self.events.append(\n                ContinuousEvent(\n                    at=at,\n                    interval=interval,\n                    duration=duration,\n                    precursor=precursor,\n                    action=func,\n                    priority=priority,\n                    label=label,\n                    **kwargs,\n                )\n            )\n\n        # create the instant event that will validate the entity state first, then create the continuous event\n        InstantEvent(\n            at=at,\n            action=__continous_event,\n            priority=-1,\n            label=f\"Engagement: {label}\",\n        )\n\n    return _continous_event\n</code></pre>"},{"location":"api/entity/#Akatosh.entity.Entity.create","title":"<code>create(at, force=False)</code>","text":"<p>The creation of the entity.</p> Source code in <code>Akatosh\\entity.py</code> <pre><code>def create(self, at: int | float, force=False) -&gt; None:\n    \"\"\"The creation of the entity.\"\"\"\n    if self.created:\n        logger.warning(f\"Entity {self.label} is already created.\")\n        return\n\n    # check if the entity is already over due\n    if self.terminated or self.destroied:\n        logger.debug(f\"Entity {self.label} is already terminated or destoried.\")\n        return\n\n    # call back function for creation\n    def _create():\n        if self.created:\n            return\n        self._created_at = Mundus.now\n        self._state.append(State.CREATED)\n        self.on_creation()\n        logger.debug(f\"Entity {self.label} created at {at}\")\n\n    self._to_be_created_at = max([at, self.to_be_created_at])\n\n    # force creation if force is True, regardless of the precursor and the time\n    if force:\n        self._creation = InstantEvent(\n            at=self.to_be_created_at,\n            action=_create,\n            label=f\"Creation of {self.label}\",\n            priority=-2,\n        )\n        if self.to_be_terminated_at != inf:\n            self.terminate(self.to_be_terminated_at)\n    else:\n        # check if all precursors are terminated, if so, create the entity\n        if len(self.precursor) != 0:\n            if all(p.terminated for p in self.precursor):\n                self._creation = InstantEvent(\n                    at=self.to_be_created_at,\n                    action=_create,\n                    label=f\"Creation of {self.label}\",\n                    priority=-2,\n                )\n                if self.to_be_terminated_at != inf:\n                    self.terminate(self.to_be_terminated_at)\n            else:\n                logger.debug(f\"Entity {self.label} is not created due to unfinished precursors.\")\n        # no precursor, create the entity\n        else:\n            self._creation = InstantEvent(\n                at=self.to_be_created_at,\n                action=_create,\n                label=f\"Creation of {self.label}\",\n                priority=-2,\n            )\n            if self.to_be_terminated_at != inf:\n                self.terminate(self.to_be_terminated_at)\n</code></pre>"},{"location":"api/entity/#Akatosh.entity.Entity.destory","title":"<code>destory(at)</code>","text":"<p>The Destruction of the entity. This will release all occupied resource, remove the entity from all entity lists, and cancel all unfinished events. This will not trigger the creation of followers.</p> Source code in <code>Akatosh\\entity.py</code> <pre><code>def destory(self, at: int | float) -&gt; None:\n    \"\"\"The Destruction of the entity. This will release all occupied resource, remove the entity from all entity lists, and cancel all unfinished events. This will not trigger the creation of followers.\"\"\"\n\n    if self.terminated or self.destroied:\n        logger.warning(f\"Entity {self.label} is already destroied.\")\n        return\n\n    def _destroy():\n        if self.terminated or self.destroied:\n            return\n        self._terminated_at = Mundus.now\n        self._state.append(State.TERMINATED)\n        self._state.append(State.DESTROIED)\n        self.release_resources()\n        self.unregister_from_lists()\n        self.cancel_unfinished_events()\n        self.on_destruction()\n        logger.debug(f\"Entity {self.label} destoried at {Mundus.now}\")\n\n    # if self._destruction is not None:\n    #     self._destruction.cancel()\n\n    # if self._termination is not None and self.to_be_terminated_at &lt; at:\n    #     return\n\n    if self._termination is not None:\n        if self._termination.at &lt; at:\n            logger.debug(f\"Entity {self.label} is already scheduled to be terminated at {self._termination.at}, so this destruction is ignored\")\n            return\n\n    if self._destruction is not None:\n        if self._destruction.at &lt; at:\n            logger.debug(f\"Entity {self.label} is already scheduled to be destoried at {self._destruction.at}, so this destruction is ignored\")\n            return\n    else:\n        self._to_be_destoried = at\n\n    self._destruction = InstantEvent(\n        at=self.to_be_terminated_at if self.to_be_terminated_at &lt; at else at,\n        action=_destroy,\n        label=f\"Destruction of {self.label}\",\n        priority=-2,\n    )\n</code></pre>"},{"location":"api/entity/#Akatosh.entity.Entity.get","title":"<code>get(resource, amount=None)</code>","text":"<p>Consume certain amout from a resource. if no amount is specified, consume all.</p> Source code in <code>Akatosh\\entity.py</code> <pre><code>def get(\n    self, resource: Resource, amount: int | float | Callable | None = None\n) -&gt; None:\n    \"\"\"Consume certain amout from a resource. if no amount is specified, consume all.\"\"\"\n\n    if not self.created:\n        raise RuntimeError(\n            f\"Entity {self} is not created yet, can not interact with any resource.\"\n        )\n\n    if self.terminated:\n        raise RuntimeError(\n            f\"Entity {self} is already terminated, can not interact with any resource.\"\n        )\n\n    if amount:\n        if callable(amount):\n            resource.distribute(self, amount())\n            if resource not in self.ocupied_resources:\n                self.ocupied_resources.append(resource)\n        else:\n            resource.distribute(self, amount)\n            if resource not in self.ocupied_resources:\n                self.ocupied_resources.append(resource)\n    else:\n        resource.distribute(self, resource.amount)\n</code></pre>"},{"location":"api/entity/#Akatosh.entity.Entity.instant_event","title":"<code>instant_event(at, precursor=None, priority=0, label=None, **kwargs)</code>","text":"<p>Decorator for creating instant event.</p> <p>Parameters:</p> Name Type Description Default <code>at</code> <code>int | float | Callable</code> <p>When the event happens.</p> required <code>precursor</code> <code>Event | List[Event] | None</code> <p>The precursor events. Defaults to None.</p> <code>None</code> <code>priority</code> <code>int | float | Callable</code> <p>The priority of the event. Defaults to 0.</p> <code>0</code> <code>label</code> <code>str | None</code> <p>Short description of the event. Defaults to None.</p> <code>None</code> Source code in <code>Akatosh\\entity.py</code> <pre><code>def instant_event(\n    self,\n    at: int | float | Callable,\n    precursor: Event | List[Event] | None = None,\n    priority: int | float | Callable = 0,\n    label: str | None = None,\n    **kwargs,\n):\n    \"\"\"Decorator for creating instant event.\n\n    Args:\n        at (int | float | Callable): When the event happens.\n        precursor (Event | List[Event] | None, optional): The precursor events. Defaults to None.\n        priority (int | float | Callable, optional): The priority of the event. Defaults to 0.\n        label (str | None, optional): Short description of the event. Defaults to None.\n    \"\"\"\n\n    def _instant_event(func: Callable):\n        def __instant_event():\n            if not self.created:\n                raise RuntimeError(\n                    f\"Entity {self} is not created yet, can not engage in any event.\"\n                )\n            if self.terminated:\n                raise RuntimeError(\n                    f\"Entity {self} is already terminated, can not engage in any event.\"\n                )\n\n            self.events.append(\n                InstantEvent(\n                    at=at,\n                    precursor=precursor,\n                    action=func,\n                    priority=priority,\n                    label=label,\n                    **kwargs,\n                )\n            )\n\n        # create the instant event that will validate the entity state first, then create the event\n        InstantEvent(\n            at=at, action=__instant_event, priority=-1, label=f\"Engagement: {label}\"\n        )\n\n    return _instant_event\n</code></pre>"},{"location":"api/entity/#Akatosh.entity.Entity.on_creation","title":"<code>on_creation()</code>  <code>abstractmethod</code>","text":"<p>Callback function upon creation of the entity</p> Source code in <code>Akatosh\\entity.py</code> <pre><code>@abstractmethod\ndef on_creation(self):\n    \"\"\"Callback function upon creation of the entity\"\"\"\n    pass\n</code></pre>"},{"location":"api/entity/#Akatosh.entity.Entity.on_destruction","title":"<code>on_destruction()</code>  <code>abstractmethod</code>","text":"<p>Callback function upon destruction of the entity</p> Source code in <code>Akatosh\\entity.py</code> <pre><code>@abstractmethod\ndef on_destruction(self):\n    \"\"\"Callback function upon destruction of the entity\"\"\"\n    pass\n</code></pre>"},{"location":"api/entity/#Akatosh.entity.Entity.on_termination","title":"<code>on_termination()</code>  <code>abstractmethod</code>","text":"<p>Callback function upon termination of the entity</p> Source code in <code>Akatosh\\entity.py</code> <pre><code>@abstractmethod\ndef on_termination(self):\n    \"\"\"Callback function upon termination of the entity\"\"\"\n    pass\n</code></pre>"},{"location":"api/entity/#Akatosh.entity.Entity.put","title":"<code>put(resource, amount=None)</code>","text":"<p>Return certain amout to a resource. if no amount is specified, return all.</p> Source code in <code>Akatosh\\entity.py</code> <pre><code>def put(\n    self, resource: Resource, amount: int | float | Callable | None = None\n) -&gt; None:\n    \"\"\"Return certain amout to a resource. if no amount is specified, return all.\"\"\"\n    if not self.created:\n        raise RuntimeError(\n            f\"Entity {self} is not created yet, can not interact any resource.\"\n        )\n\n    if self.terminated:\n        raise RuntimeError(\n            f\"Entity {self} is already terminated, can not interact any resource.\"\n        )\n\n    if amount:\n        if callable(amount):\n            resource.collect(self, amount())\n            if self not in resource.users:\n                self.ocupied_resources.remove(resource)\n        else:\n            resource.collect(self, amount)\n            if self not in resource.users:\n                self.ocupied_resources.remove(resource)\n    else:\n        resource.collect(self)\n</code></pre>"},{"location":"api/entity/#Akatosh.entity.Entity.release_resources","title":"<code>release_resources()</code>","text":"<p>Release all occupied resources.</p> Source code in <code>Akatosh\\entity.py</code> <pre><code>def release_resources(self):\n    \"\"\"Release all occupied resources.\"\"\"\n    for res in self.ocupied_resources:\n        res.collect(self)\n</code></pre>"},{"location":"api/entity/#Akatosh.entity.Entity.terminate","title":"<code>terminate(at)</code>","text":"<p>The termination of the entity. This will release all occupied resource, remove the entity from all entity lists, and cancel all unfinished events.</p> Source code in <code>Akatosh\\entity.py</code> <pre><code>def terminate(self, at: int | float) -&gt; None:\n    \"\"\"The termination of the entity. This will release all occupied resource, remove the entity from all entity lists, and cancel all unfinished events.\"\"\"\n\n    if self.terminated or self.destroied:\n        logger.warning(f\"Entity {self.label} is already terminated or destoried.\")\n        return\n\n    def _terminate():\n        if self.terminated or self.destroied:\n            return\n        if not self.created:\n            logger.warning(f\"Entity {self.label} is not created yet, so considered destoried.\")\n            self.destory(Mundus.now)\n            return\n        self._terminated_at = Mundus.now\n        self._state.append(State.TERMINATED)\n        self.release_resources()\n        self.unregister_from_lists()\n        self.cancel_unfinished_events()\n        self.on_termination()\n        logger.debug(f\"Entity {self.label} terminated at {Mundus.now}\")\n        for entity in self._followers:\n            entity.create(Mundus.now)\n\n    # check if a later termination is scheduled\n    # if self._to_be_terminated_at &gt; at:\n    #     self._to_be_terminated_at = at\n\n    # if self._termination is not None:\n    #     self._termination.cancel()\n    if self._termination is not None:\n        if self._termination.at &gt; at:\n            self._termination.cancel()\n            self._to_be_terminated_at = at\n        else:\n            logger.debug(f\"Entity {self.label} is already scheduled to be terminated at {self._termination.at}.\")\n            return\n    else:\n        self._to_be_terminated_at = at\n\n    self._termination = InstantEvent(\n        at=self.to_be_terminated_at,\n        action=_terminate,\n        label=f\"Termination of {self.label}\",\n        priority=-2,\n    )\n</code></pre>"},{"location":"api/entity/#Akatosh.entity.Entity.unregister_from_lists","title":"<code>unregister_from_lists()</code>","text":"<p>Remove this entity from all registered entity lists.</p> Source code in <code>Akatosh\\entity.py</code> <pre><code>def unregister_from_lists(self):\n    \"\"\"Remove this entity from all registered entity lists.\"\"\"\n    for list in self.registered_lists[:]:\n        list.remove(self)\n</code></pre>"},{"location":"api/entity_list/","title":"EntityList","text":"<p>             Bases: <code>list</code></p> <p>Customized list for entities. This list ensures all items are entities and unique. When an entity is terminated, it will be removed from all entity lists automatically.</p> Source code in <code>Akatosh\\entity.py</code> <pre><code>class EntityList(list):\n    \"\"\"Customized list for entities. This list ensures all items are entities and unique. When an entity is terminated, it will be removed from all entity lists automatically.\"\"\"\n\n    def __init__(self, iterable: Iterable[Entity] = [], label: str | None = None):\n        \"\"\"Create a list for entities, with optional label.\n\n        Args:\n            iterable (Iterable[Entity]): Iterable of entities.\n        \"\"\"\n        super().__init__(item for item in iterable if isinstance(item, Entity))\n        self._label = label\n        self._id = uuid4().int\n\n    def insert(self, __index: int, __object: Entity) -&gt; None:\n        \"\"\"Insert an entity to the list.\n\n        Args:\n            __index (SupportsIndex): the index to insert the entity.\n            __object (Entity): the entity to be inserted.\n        \"\"\"\n        if __object not in self:\n            super().insert(__index, __object)\n            if self not in __object.registered_lists:\n                __object.registered_lists.append(self)\n            logger.debug(\n                f\"Entity {__object.label} is inserted to {self.label if self.label else self} at {__index}.\"\n            )\n\n    def append(self, __object: Entity) -&gt; None:\n        \"\"\"Append an entity to the list.\n\n        Args:\n            __object (Entity): the entity to be appended.\n        \"\"\"\n        if __object not in self:\n            super().append(__object)\n            if self not in __object.registered_lists:\n                __object.registered_lists.append(self)\n            logger.debug(\n                f\"Entity {__object.label} is appended to {self.label if self.label else self}.\"\n            )\n\n    def remove(self, __object: Entity) -&gt; None:\n        \"\"\"Remove an entity from the list.\n\n        Args:\n            __object (Entity): the entity to be removed.\n        \"\"\"\n        super().remove(__object)\n        if self in __object.registered_lists:\n            __object.registered_lists.remove(self)\n        logger.debug(\n            f\"Entity {__object.label} is removed from {self.label if self.label else self}.\"\n        )\n\n    def pop(self, __index: int = None) -&gt; Entity: # type: ignore\n        \"\"\"Pop an entity from the list.\n\n        Args:\n            __index (int, optional): the index. Defaults to ... (the last one).\n\n        Returns:\n            Entity: return the poped entity.\n        \"\"\"\n        __object: Entity = super().pop(__index)\n        if self in __object.registered_lists:\n            __object.registered_lists.remove(self)\n        logger.debug(\n            f\"Entity {__object.label} is poped from {self.label if self.label else self} at {__index}.\"\n        )\n        return __object\n\n    def clear(self) -&gt; None:\n        \"\"\"Clear the list.\"\"\"\n        for item in self:\n            if self in item.registered_lists:\n                item.registered_lists.remove(self)\n        super().clear()\n        logger.debug(f\"{self.label if self.label else self} is cleared.\")\n\n    def extend(self, __iterable: Iterable[Entity]) -&gt; None:\n        \"\"\"Extend the list with an iterable of entities.\n\n        Args:\n            __iterable (Iterable[Entity]): the iterable of entities.\n        \"\"\"\n        for item in __iterable:\n            if item not in self:\n                super().append(item)\n        for item in __iterable:\n            if self not in item.registered_lists:\n                item.registered_lists.append(self)\n        logger.debug(\n            f\"{self.label if self.label else self} is extended with {__iterable}.\"\n        )\n\n    def __eq__(self, __value: EntityList) -&gt; bool:\n        if self.id == __value.id:\n            return True\n        else:\n            return False\n\n    @property\n    def label(self):\n        \"\"\"Return the label of the entity list.\"\"\"\n        return self._label\n\n    @property\n    def id(self):\n        \"\"\"Return the id of the entity list.\"\"\"\n        return self._id\n</code></pre>"},{"location":"api/entity_list/#Akatosh.entity.EntityList.id","title":"<code>id</code>  <code>property</code>","text":"<p>Return the id of the entity list.</p>"},{"location":"api/entity_list/#Akatosh.entity.EntityList.label","title":"<code>label</code>  <code>property</code>","text":"<p>Return the label of the entity list.</p>"},{"location":"api/entity_list/#Akatosh.entity.EntityList.__init__","title":"<code>__init__(iterable=[], label=None)</code>","text":"<p>Create a list for entities, with optional label.</p> <p>Parameters:</p> Name Type Description Default <code>iterable</code> <code>Iterable[Entity]</code> <p>Iterable of entities.</p> <code>[]</code> Source code in <code>Akatosh\\entity.py</code> <pre><code>def __init__(self, iterable: Iterable[Entity] = [], label: str | None = None):\n    \"\"\"Create a list for entities, with optional label.\n\n    Args:\n        iterable (Iterable[Entity]): Iterable of entities.\n    \"\"\"\n    super().__init__(item for item in iterable if isinstance(item, Entity))\n    self._label = label\n    self._id = uuid4().int\n</code></pre>"},{"location":"api/entity_list/#Akatosh.entity.EntityList.append","title":"<code>append(__object)</code>","text":"<p>Append an entity to the list.</p> <p>Parameters:</p> Name Type Description Default <code>__object</code> <code>Entity</code> <p>the entity to be appended.</p> required Source code in <code>Akatosh\\entity.py</code> <pre><code>def append(self, __object: Entity) -&gt; None:\n    \"\"\"Append an entity to the list.\n\n    Args:\n        __object (Entity): the entity to be appended.\n    \"\"\"\n    if __object not in self:\n        super().append(__object)\n        if self not in __object.registered_lists:\n            __object.registered_lists.append(self)\n        logger.debug(\n            f\"Entity {__object.label} is appended to {self.label if self.label else self}.\"\n        )\n</code></pre>"},{"location":"api/entity_list/#Akatosh.entity.EntityList.clear","title":"<code>clear()</code>","text":"<p>Clear the list.</p> Source code in <code>Akatosh\\entity.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Clear the list.\"\"\"\n    for item in self:\n        if self in item.registered_lists:\n            item.registered_lists.remove(self)\n    super().clear()\n    logger.debug(f\"{self.label if self.label else self} is cleared.\")\n</code></pre>"},{"location":"api/entity_list/#Akatosh.entity.EntityList.extend","title":"<code>extend(__iterable)</code>","text":"<p>Extend the list with an iterable of entities.</p> <p>Parameters:</p> Name Type Description Default <code>__iterable</code> <code>Iterable[Entity]</code> <p>the iterable of entities.</p> required Source code in <code>Akatosh\\entity.py</code> <pre><code>def extend(self, __iterable: Iterable[Entity]) -&gt; None:\n    \"\"\"Extend the list with an iterable of entities.\n\n    Args:\n        __iterable (Iterable[Entity]): the iterable of entities.\n    \"\"\"\n    for item in __iterable:\n        if item not in self:\n            super().append(item)\n    for item in __iterable:\n        if self not in item.registered_lists:\n            item.registered_lists.append(self)\n    logger.debug(\n        f\"{self.label if self.label else self} is extended with {__iterable}.\"\n    )\n</code></pre>"},{"location":"api/entity_list/#Akatosh.entity.EntityList.insert","title":"<code>insert(__index, __object)</code>","text":"<p>Insert an entity to the list.</p> <p>Parameters:</p> Name Type Description Default <code>__index</code> <code>SupportsIndex</code> <p>the index to insert the entity.</p> required <code>__object</code> <code>Entity</code> <p>the entity to be inserted.</p> required Source code in <code>Akatosh\\entity.py</code> <pre><code>def insert(self, __index: int, __object: Entity) -&gt; None:\n    \"\"\"Insert an entity to the list.\n\n    Args:\n        __index (SupportsIndex): the index to insert the entity.\n        __object (Entity): the entity to be inserted.\n    \"\"\"\n    if __object not in self:\n        super().insert(__index, __object)\n        if self not in __object.registered_lists:\n            __object.registered_lists.append(self)\n        logger.debug(\n            f\"Entity {__object.label} is inserted to {self.label if self.label else self} at {__index}.\"\n        )\n</code></pre>"},{"location":"api/entity_list/#Akatosh.entity.EntityList.pop","title":"<code>pop(__index=None)</code>","text":"<p>Pop an entity from the list.</p> <p>Parameters:</p> Name Type Description Default <code>__index</code> <code>int</code> <p>the index. Defaults to ... (the last one).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Entity</code> <code>Entity</code> <p>return the poped entity.</p> Source code in <code>Akatosh\\entity.py</code> <pre><code>def pop(self, __index: int = None) -&gt; Entity: # type: ignore\n    \"\"\"Pop an entity from the list.\n\n    Args:\n        __index (int, optional): the index. Defaults to ... (the last one).\n\n    Returns:\n        Entity: return the poped entity.\n    \"\"\"\n    __object: Entity = super().pop(__index)\n    if self in __object.registered_lists:\n        __object.registered_lists.remove(self)\n    logger.debug(\n        f\"Entity {__object.label} is poped from {self.label if self.label else self} at {__index}.\"\n    )\n    return __object\n</code></pre>"},{"location":"api/entity_list/#Akatosh.entity.EntityList.remove","title":"<code>remove(__object)</code>","text":"<p>Remove an entity from the list.</p> <p>Parameters:</p> Name Type Description Default <code>__object</code> <code>Entity</code> <p>the entity to be removed.</p> required Source code in <code>Akatosh\\entity.py</code> <pre><code>def remove(self, __object: Entity) -&gt; None:\n    \"\"\"Remove an entity from the list.\n\n    Args:\n        __object (Entity): the entity to be removed.\n    \"\"\"\n    super().remove(__object)\n    if self in __object.registered_lists:\n        __object.registered_lists.remove(self)\n    logger.debug(\n        f\"Entity {__object.label} is removed from {self.label if self.label else self}.\"\n    )\n</code></pre>"},{"location":"api/event/","title":"Event","text":"Source code in <code>Akatosh\\event.py</code> <pre><code>class Event:\n    def __init__(\n        self,\n        at: int | float | Callable[..., int] | Callable[..., float],\n        precursor: Event | List[Event] | None = None,\n        action: Callable | None = None,\n        priority: int | float | Callable[..., int] | Callable[..., float] = 0,\n        label: str | None = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Base class for all events.\n\n        Args:\n            at (int | float | Callable[...,int] | Callable[...,float]): the time when the event happens.\n            precursor (Event | List[Event] | None, optional): the precursor events. Defaults to None.\n            action (Callable | None, optional): the actual action of the event, must be defined. Defaults to None.\n            priority (int | float | Callable[...,int] | Callable[...,float], optional): the priority of the event. When multiple event happen at the same time, the event with lower priority value will happen first. Defaults to 0.\n            label (str | None, optional): Short descirption of the event. Defaults to None.\n        \"\"\"\n        self._id = uuid4().int\n        # set the time\n        if callable(at):\n            self._at = round(at(), Mundus.resolution)\n        else:\n            self._at = round(at, Mundus.resolution)\n        # set the target event(s) that this event should wait and follow\n        if isinstance(precursor, list):\n            self._precursor = precursor\n        elif precursor is None:\n            self._precursor = []\n        else:\n            self._precursor = [precursor]\n        self._follower: List[Event] = []\n        for event in self.precursor:\n            event._follower.append(self)\n        # set the state\n        if len(self.precursor) != 0:\n            self.state = State.INACTIVE\n        else:\n            self.state = State.ACTIVE\n        # set the action and the priority\n        if action:\n            self._action = action\n        if callable(priority):\n            self._priority = priority()\n        else:\n            self._priority = priority\n        # assign label\n        self._label = label\n        # add to the universe\n        if Mundus.now &lt; self.at:\n            Mundus.future_events.append(self)\n        elif Mundus.now &gt; self.at:\n            raise RuntimeError(f\"Event {self.label} tries to alter the past.\")\n        else:\n            Mundus.current_events.append(self)\n\n    def end(self):\n        \"\"\"End the event and activate the follower events if there is any.\"\"\"\n        if self.ended:\n            return\n\n        self.state = State.ENDED\n        if self in Mundus.future_events:\n            Mundus.future_events.remove(self)\n        if self in Mundus.current_events:\n            Mundus.current_events.remove(self)\n        Mundus.past_events.append(self)\n        for event in self.follower:\n            try:\n                event.activate()\n            except RuntimeError:\n                logger.debug(f\"Event {event.label} passed due time.\")\n        logger.debug(f\"Event {self.label} is ended.\")\n\n    def activate(self, force: bool = False):\n        \"\"\"Activate the event.\"\"\"\n\n        # raise error if the event has already ended\n        if self.ended:\n            raise RuntimeError(f\"Event {self.label} has already ended.\")\n\n        # raise warning if the event is cancelled\n        if self.cancelled:\n            warnings.warn(f\"Event {self.label} is cancelled.\")\n            return\n\n        # return if the event is already active\n        if self.active:\n            return\n\n        if force:\n            self.state = State.ACTIVE\n            if self._at &lt; Mundus.now:\n                self._at = Mundus.now\n            logger.debug(f\"Event {self.label} is set to active.\")\n        else:\n            if all(e.state == State.ENDED for e in self.precursor):\n                self.state = State.ACTIVE\n                if self._at &lt; Mundus.now:\n                    self._at = Mundus.now\n                logger.debug(f\"Event {self.label} is set to active.\")\n            else:\n                warnings.warn(f\"Event {self.label} is waiting for other events to end.\")\n                return\n\n    def deactivate(self):\n        \"\"\"Deactivate the event.\n\n        Raises:\n            RuntimeError: raise if the event has already ended.\n        \"\"\"\n\n        # raise error if the event has already ended\n        if self.ended:\n            raise RuntimeError(f\"Event {self.label} has already ended.\")\n\n        # raise warning if the event is cancelled\n        if self.cancelled:\n            warnings.warn(f\"Event {self.label} is cancelled.\")\n            return\n\n        # return if the event is already inactive\n        if self.inactive:\n            return\n\n        self.state = State.INACTIVE\n\n    def cancel(self):\n        \"\"\"Cancel the event. Will not set the follower events to active.\n\n        Raises:\n            RuntimeError: raise if the event has already ended.\n        \"\"\"\n\n        # raise error if the event has already ended\n        if self.ended:\n            raise RuntimeError(f\"Event {self.label} has already ended.\")\n\n        # return if the event is already cancelled\n        if self.cancelled:\n            return\n\n        self.state = State.CANCELED\n        if self in Mundus.future_events:\n            Mundus.future_events.remove(self)\n        if self in Mundus.current_events:\n            Mundus.current_events.remove(self)\n        Mundus.past_events.append(self)\n        logger.debug(f\"Event {self.label} is cancelled.\")\n\n    @abstractmethod\n    async def _perform(self):\n        \"\"\"Abstract method for the event to perform its action.\"\"\"\n        pass\n\n    def __eq__(self, _o: Event) -&gt; bool:\n        \"\"\"Determine if two events are the same.\"\"\"\n        return self.id == _o.id\n\n    @property\n    def id(self) -&gt; int:\n        \"\"\"Return the unique id of the event.\"\"\"\n        return self._id\n\n    @property\n    def label(self) -&gt; str | None:\n        \"\"\"Return the label of the event.\"\"\"\n        return self._label\n\n    @property\n    def at(self) -&gt; int | float:\n        \"\"\"Return the time when the event happens.\"\"\"\n        return self._at\n\n    @property\n    def precursor(self) -&gt; List[Event]:\n        \"\"\"Return the precursor events.\"\"\"\n        return self._precursor\n\n    @property\n    def follower(self) -&gt; List[Event]:\n        \"\"\"Return the follower events.\"\"\"\n        return self._follower\n\n    @property\n    def action(self) -&gt; Callable | None:\n        \"\"\"Return the action of the event.\"\"\"\n        return self._action\n\n    @property\n    def priority(self) -&gt; int | float:\n        \"\"\"Return the priority of the event.\"\"\"\n        return self._priority\n\n    @property\n    def state(self) -&gt; str:\n        \"\"\"Return the state of the event.\"\"\"\n        return self._state\n\n    @state.setter\n    def state(self, state: str):\n        \"\"\"Set the state of the event.\"\"\"\n        self._state = state\n\n    @property\n    def active(self) -&gt; bool:\n        \"\"\"Return True if the event is active.\"\"\"\n        return State.ACTIVE == self.state\n\n    @property\n    def inactive(self) -&gt; bool:\n        \"\"\"Return True if the event is inactive.\"\"\"\n        return State.INACTIVE == self.state\n\n    @property\n    def cancelled(self) -&gt; bool:\n        \"\"\"Return True if the event is cancelled.\"\"\"\n        return State.CANCELED == self.state\n\n    @property\n    def ended(self) -&gt; bool:\n        \"\"\"Return True if the event is ended.\"\"\"\n        return State.ENDED == self.state\n</code></pre>"},{"location":"api/event/#Akatosh.event.Event.action","title":"<code>action: Callable | None</code>  <code>property</code>","text":"<p>Return the action of the event.</p>"},{"location":"api/event/#Akatosh.event.Event.active","title":"<code>active: bool</code>  <code>property</code>","text":"<p>Return True if the event is active.</p>"},{"location":"api/event/#Akatosh.event.Event.at","title":"<code>at: int | float</code>  <code>property</code>","text":"<p>Return the time when the event happens.</p>"},{"location":"api/event/#Akatosh.event.Event.cancelled","title":"<code>cancelled: bool</code>  <code>property</code>","text":"<p>Return True if the event is cancelled.</p>"},{"location":"api/event/#Akatosh.event.Event.ended","title":"<code>ended: bool</code>  <code>property</code>","text":"<p>Return True if the event is ended.</p>"},{"location":"api/event/#Akatosh.event.Event.follower","title":"<code>follower: List[Event]</code>  <code>property</code>","text":"<p>Return the follower events.</p>"},{"location":"api/event/#Akatosh.event.Event.id","title":"<code>id: int</code>  <code>property</code>","text":"<p>Return the unique id of the event.</p>"},{"location":"api/event/#Akatosh.event.Event.inactive","title":"<code>inactive: bool</code>  <code>property</code>","text":"<p>Return True if the event is inactive.</p>"},{"location":"api/event/#Akatosh.event.Event.label","title":"<code>label: str | None</code>  <code>property</code>","text":"<p>Return the label of the event.</p>"},{"location":"api/event/#Akatosh.event.Event.precursor","title":"<code>precursor: List[Event]</code>  <code>property</code>","text":"<p>Return the precursor events.</p>"},{"location":"api/event/#Akatosh.event.Event.priority","title":"<code>priority: int | float</code>  <code>property</code>","text":"<p>Return the priority of the event.</p>"},{"location":"api/event/#Akatosh.event.Event.state","title":"<code>state: str</code>  <code>property</code> <code>writable</code>","text":"<p>Return the state of the event.</p>"},{"location":"api/event/#Akatosh.event.Event.__eq__","title":"<code>__eq__(_o)</code>","text":"<p>Determine if two events are the same.</p> Source code in <code>Akatosh\\event.py</code> <pre><code>def __eq__(self, _o: Event) -&gt; bool:\n    \"\"\"Determine if two events are the same.\"\"\"\n    return self.id == _o.id\n</code></pre>"},{"location":"api/event/#Akatosh.event.Event.__init__","title":"<code>__init__(at, precursor=None, action=None, priority=0, label=None, **kwargs)</code>","text":"<p>Base class for all events.</p> <p>Parameters:</p> Name Type Description Default <code>at</code> <code>int | float | Callable[..., int] | Callable[..., float]</code> <p>the time when the event happens.</p> required <code>precursor</code> <code>Event | List[Event] | None</code> <p>the precursor events. Defaults to None.</p> <code>None</code> <code>action</code> <code>Callable | None</code> <p>the actual action of the event, must be defined. Defaults to None.</p> <code>None</code> <code>priority</code> <code>int | float | Callable[..., int] | Callable[..., float]</code> <p>the priority of the event. When multiple event happen at the same time, the event with lower priority value will happen first. Defaults to 0.</p> <code>0</code> <code>label</code> <code>str | None</code> <p>Short descirption of the event. Defaults to None.</p> <code>None</code> Source code in <code>Akatosh\\event.py</code> <pre><code>def __init__(\n    self,\n    at: int | float | Callable[..., int] | Callable[..., float],\n    precursor: Event | List[Event] | None = None,\n    action: Callable | None = None,\n    priority: int | float | Callable[..., int] | Callable[..., float] = 0,\n    label: str | None = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Base class for all events.\n\n    Args:\n        at (int | float | Callable[...,int] | Callable[...,float]): the time when the event happens.\n        precursor (Event | List[Event] | None, optional): the precursor events. Defaults to None.\n        action (Callable | None, optional): the actual action of the event, must be defined. Defaults to None.\n        priority (int | float | Callable[...,int] | Callable[...,float], optional): the priority of the event. When multiple event happen at the same time, the event with lower priority value will happen first. Defaults to 0.\n        label (str | None, optional): Short descirption of the event. Defaults to None.\n    \"\"\"\n    self._id = uuid4().int\n    # set the time\n    if callable(at):\n        self._at = round(at(), Mundus.resolution)\n    else:\n        self._at = round(at, Mundus.resolution)\n    # set the target event(s) that this event should wait and follow\n    if isinstance(precursor, list):\n        self._precursor = precursor\n    elif precursor is None:\n        self._precursor = []\n    else:\n        self._precursor = [precursor]\n    self._follower: List[Event] = []\n    for event in self.precursor:\n        event._follower.append(self)\n    # set the state\n    if len(self.precursor) != 0:\n        self.state = State.INACTIVE\n    else:\n        self.state = State.ACTIVE\n    # set the action and the priority\n    if action:\n        self._action = action\n    if callable(priority):\n        self._priority = priority()\n    else:\n        self._priority = priority\n    # assign label\n    self._label = label\n    # add to the universe\n    if Mundus.now &lt; self.at:\n        Mundus.future_events.append(self)\n    elif Mundus.now &gt; self.at:\n        raise RuntimeError(f\"Event {self.label} tries to alter the past.\")\n    else:\n        Mundus.current_events.append(self)\n</code></pre>"},{"location":"api/event/#Akatosh.event.Event.activate","title":"<code>activate(force=False)</code>","text":"<p>Activate the event.</p> Source code in <code>Akatosh\\event.py</code> <pre><code>def activate(self, force: bool = False):\n    \"\"\"Activate the event.\"\"\"\n\n    # raise error if the event has already ended\n    if self.ended:\n        raise RuntimeError(f\"Event {self.label} has already ended.\")\n\n    # raise warning if the event is cancelled\n    if self.cancelled:\n        warnings.warn(f\"Event {self.label} is cancelled.\")\n        return\n\n    # return if the event is already active\n    if self.active:\n        return\n\n    if force:\n        self.state = State.ACTIVE\n        if self._at &lt; Mundus.now:\n            self._at = Mundus.now\n        logger.debug(f\"Event {self.label} is set to active.\")\n    else:\n        if all(e.state == State.ENDED for e in self.precursor):\n            self.state = State.ACTIVE\n            if self._at &lt; Mundus.now:\n                self._at = Mundus.now\n            logger.debug(f\"Event {self.label} is set to active.\")\n        else:\n            warnings.warn(f\"Event {self.label} is waiting for other events to end.\")\n            return\n</code></pre>"},{"location":"api/event/#Akatosh.event.Event.cancel","title":"<code>cancel()</code>","text":"<p>Cancel the event. Will not set the follower events to active.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>raise if the event has already ended.</p> Source code in <code>Akatosh\\event.py</code> <pre><code>def cancel(self):\n    \"\"\"Cancel the event. Will not set the follower events to active.\n\n    Raises:\n        RuntimeError: raise if the event has already ended.\n    \"\"\"\n\n    # raise error if the event has already ended\n    if self.ended:\n        raise RuntimeError(f\"Event {self.label} has already ended.\")\n\n    # return if the event is already cancelled\n    if self.cancelled:\n        return\n\n    self.state = State.CANCELED\n    if self in Mundus.future_events:\n        Mundus.future_events.remove(self)\n    if self in Mundus.current_events:\n        Mundus.current_events.remove(self)\n    Mundus.past_events.append(self)\n    logger.debug(f\"Event {self.label} is cancelled.\")\n</code></pre>"},{"location":"api/event/#Akatosh.event.Event.deactivate","title":"<code>deactivate()</code>","text":"<p>Deactivate the event.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>raise if the event has already ended.</p> Source code in <code>Akatosh\\event.py</code> <pre><code>def deactivate(self):\n    \"\"\"Deactivate the event.\n\n    Raises:\n        RuntimeError: raise if the event has already ended.\n    \"\"\"\n\n    # raise error if the event has already ended\n    if self.ended:\n        raise RuntimeError(f\"Event {self.label} has already ended.\")\n\n    # raise warning if the event is cancelled\n    if self.cancelled:\n        warnings.warn(f\"Event {self.label} is cancelled.\")\n        return\n\n    # return if the event is already inactive\n    if self.inactive:\n        return\n\n    self.state = State.INACTIVE\n</code></pre>"},{"location":"api/event/#Akatosh.event.Event.end","title":"<code>end()</code>","text":"<p>End the event and activate the follower events if there is any.</p> Source code in <code>Akatosh\\event.py</code> <pre><code>def end(self):\n    \"\"\"End the event and activate the follower events if there is any.\"\"\"\n    if self.ended:\n        return\n\n    self.state = State.ENDED\n    if self in Mundus.future_events:\n        Mundus.future_events.remove(self)\n    if self in Mundus.current_events:\n        Mundus.current_events.remove(self)\n    Mundus.past_events.append(self)\n    for event in self.follower:\n        try:\n            event.activate()\n        except RuntimeError:\n            logger.debug(f\"Event {event.label} passed due time.\")\n    logger.debug(f\"Event {self.label} is ended.\")\n</code></pre>"},{"location":"api/instant_event/","title":"InstantEvent","text":"<p>             Bases: <code>Event</code></p> <p>Instant event is an event that happens at a specific time and only happens once.</p> Source code in <code>Akatosh\\event.py</code> <pre><code>class InstantEvent(Event):\n    \"\"\"Instant event is an event that happens at a specific time and only happens once.\"\"\"\n\n    def __init__(\n        self,\n        at: int | float | Callable[..., int] | Callable[..., float],\n        precursor: Event | List[Event] | None = None,\n        action: Callable[..., Any] | None = None,\n        priority: int | float | Callable[..., int] | Callable[..., float] = 0,\n        label: str | None = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Create a instant event.\n\n        Args:\n            at (int | float | Callable[...,int] | Callable[...,float]): the time when the event happens.\n            precursor (Event | List[Event] | None, optional): the precursor events. Defaults to None.\n            action (Callable | None, optional): the actual action of the event, must be defined. Defaults to None.\n            priority (int | float | Callable[...,int] | Callable[...,float], optional): the priority of the event. When multiple event happen at the same time, the event with lower priority value will happen first. Defaults to 0.\n            label (str | None, optional): Short descirption of the event. Defaults to None.\n        \"\"\"\n        super().__init__(at, precursor, action, priority, label, **kwargs)\n\n    async def _perform(self):\n        \"\"\"Perform the action of the event.\"\"\"\n        if self.state == State.ACTIVE:\n            if self.action:\n                if inspect.iscoroutinefunction(self.action):\n                    await self.action()\n                else:\n                    self.action()\n            Mundus.current_events.remove(self)\n            Mundus.past_events.append(self)\n            self.end()\n</code></pre>"},{"location":"api/instant_event/#Akatosh.event.InstantEvent.__init__","title":"<code>__init__(at, precursor=None, action=None, priority=0, label=None, **kwargs)</code>","text":"<p>Create a instant event.</p> <p>Parameters:</p> Name Type Description Default <code>at</code> <code>int | float | Callable[..., int] | Callable[..., float]</code> <p>the time when the event happens.</p> required <code>precursor</code> <code>Event | List[Event] | None</code> <p>the precursor events. Defaults to None.</p> <code>None</code> <code>action</code> <code>Callable | None</code> <p>the actual action of the event, must be defined. Defaults to None.</p> <code>None</code> <code>priority</code> <code>int | float | Callable[..., int] | Callable[..., float]</code> <p>the priority of the event. When multiple event happen at the same time, the event with lower priority value will happen first. Defaults to 0.</p> <code>0</code> <code>label</code> <code>str | None</code> <p>Short descirption of the event. Defaults to None.</p> <code>None</code> Source code in <code>Akatosh\\event.py</code> <pre><code>def __init__(\n    self,\n    at: int | float | Callable[..., int] | Callable[..., float],\n    precursor: Event | List[Event] | None = None,\n    action: Callable[..., Any] | None = None,\n    priority: int | float | Callable[..., int] | Callable[..., float] = 0,\n    label: str | None = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Create a instant event.\n\n    Args:\n        at (int | float | Callable[...,int] | Callable[...,float]): the time when the event happens.\n        precursor (Event | List[Event] | None, optional): the precursor events. Defaults to None.\n        action (Callable | None, optional): the actual action of the event, must be defined. Defaults to None.\n        priority (int | float | Callable[...,int] | Callable[...,float], optional): the priority of the event. When multiple event happen at the same time, the event with lower priority value will happen first. Defaults to 0.\n        label (str | None, optional): Short descirption of the event. Defaults to None.\n    \"\"\"\n    super().__init__(at, precursor, action, priority, label, **kwargs)\n</code></pre>"},{"location":"api/resource/","title":"Resource","text":"Source code in <code>Akatosh\\resource.py</code> <pre><code>class Resource:\n    def __init__(\n        self,\n        capacity: int | float | Callable,\n        initial_amount: int | float | Callable | None = None,\n        label: str | None = None,\n    ) -&gt; None:\n        \"\"\"Resource is a class that represents a resource with capacity and amount, any object can use this resource by calling distribute() and return by calling collect() methods.\n\n        Args:\n            capacity (int | float | Callable): the capacity of the resource.\n            initial_amount (int | float | Callable | None, optional): the initial amount of the resource. Defaults to capacity.\n            label (str | None, optional): short description of the resource. Defaults to None.\n\n        Raises:\n            ValueError: raise if initial amount is greater than capacity.\n        \"\"\"\n        if callable(capacity):\n            self._capacity = capacity()\n        else:\n            self._capacity = capacity\n        if initial_amount:\n            if callable(initial_amount):\n                if initial_amount() &gt; self.capacity:\n                    raise ValueError(\"Initial amount is greater than capacity.\")\n                else:\n                    self._amount = initial_amount()\n            else:\n                if initial_amount &gt; self.capacity:\n                    raise ValueError(\"Initial amount is greater than capacity.\")\n                else:\n                    self._amount = initial_amount\n        else:\n            self._amount = self.capacity\n        self._label = label\n        self._user_records: List[\n            Tuple[object, int | float]\n        ] = list()  # (user, amount) tracking the usage of individual user\n        self._usage_records: List[\n            Tuple[int | float, int | float]\n        ] = list()  # (time, amount) tracking the usage of the resource over time\n\n    def get(self, amount: int | float) -&gt; None:\n        \"\"\"Get the amount of resource from the resource.\n\n        Args:\n            amount (int | float): the amount of resource to get.\n\n        Raises:\n            ValueError: raise if amount is greater than the current available amount of resource.\n        \"\"\"\n        if amount &gt; self.amount:\n            raise ValueError(f\"Not enough amount in Resource {self.label}.\")\n        else:\n            self._amount -= amount\n            self.usage_records.append((Mundus.now, self.amount))\n\n    def put(self, amount: int | float) -&gt; None:\n        \"\"\"Put the amount of resource back to the resource.\n\n        Args:\n            amount (int | float): the amount of resource to put.\n\n        Raises:\n            ValueError: raise if amount is greater than the current used amount of resource.\n        \"\"\"\n        if amount &gt; self.occupied:\n            raise ValueError(f\"Not enough capacity in Resource {self.label}.\")\n        else:\n            self._amount += amount\n            self.usage_records.append((Mundus.now, self.amount))\n\n    def distribute(self, user: object, amount: int | float) -&gt; None:\n        \"\"\"Distribute the amount of resource to the user.\n\n        Args:\n            user (object): the user of the resource.\n            amount (int | float): the amount of resource to distribute.\n\n        Raises:\n            ValueError: raise if amount is greater than the current available amount of resource.\n        \"\"\"\n        if amount &gt; self.amount:\n            raise ValueError(f\"Not enough amount in Resource {self.label}.\")\n        else:\n            self._amount -= amount\n            if user in self.users:\n                for index, record in enumerate(self.user_records):\n                    if record[0] is user:\n                        self.user_records[index] = (user, record[1] + amount)\n                        break\n            else:\n                self.user_records.append((user, amount))\n            self.usage_records.append((Mundus.now, self.amount))\n            logger.debug(f\"Resource {self.label} distributed {amount} to {user}.\")\n\n    def collect(self, user: object, amount: int | float | None = None) -&gt; None:\n        \"\"\"Collect the amount of resource from the user.\n\n        Args:\n            user (object): the user of the resource.\n            amount (int | float | None, optional): the amount of resource to collect. Defaults to None means collecting all resource used by the user.\n\n        Raises:\n            ValueError: raise if user is not using the resource or amount is greater than the current used amount of resource.\n        \"\"\"\n        if user not in self.users:\n            raise ValueError(f\"User {user} is not using Resource {self.label}.\")\n        if amount is None:\n            for index, record in enumerate(self.user_records):\n                if record[0] is user:\n                    self._amount += record[1]\n                    self.usage_records.append((Mundus.now, self.amount))\n                    logger.debug(\n                        f\"Resource {self.label} collected {record[1]} from {user}.\"\n                    )\n                    break\n        else:\n            for index, record in enumerate(self.user_records):\n                if record[0] is user:\n                    if record[1] &lt; amount:\n                        raise ValueError(\n                            f\"{user} occupied {record[1]} of Resource {self.label}, less than {amount}.\"\n                        )\n                    else:\n                        self.user_records[index] = (user, record[1] - amount)\n                        if self.user_records[index][1] == 0:\n                            self.user_records.pop(index)\n                        self._amount += amount\n                        self.usage_records.append((Mundus.now, self.amount))\n                        logger.debug(\n                            f\"Resource {self.label} collected {amount} from {user}.\"\n                        )\n                        break\n\n    def utilization(self, duration: int | float | Callable | None = None):\n        \"\"\"Return the utilization ( occupied amount / capacity ) of the resource in the duration.\n\n        Args:\n            duration (int | float | Callable | None, optional): the duration to trace back in time. Defaults to None.\n        \"\"\"\n        if duration:\n            if callable(duration):\n                after = Mundus.now - duration()\n            else:\n                after = Mundus.now - duration\n            if after &lt; 0:\n                after = 0\n            usage_records = [\n                usage_record\n                for usage_record in self.usage_records\n                if usage_record[0] &gt;= after\n            ]\n            if len(usage_records) == 0:\n                return 1 - (self.amount / self.capacity)\n            else:\n                if usage_records[-1][0] - after == 0:\n                    return 1 - (usage_records[-1][1] / self.capacity)\n                else:\n                    weighted_overall_amount = 0\n                    for index, record in enumerate(usage_records):\n                        if index == 0:\n                            weighted_overall_amount += record[1] * (record[0] - after)\n                        elif index == len(usage_records) - 1:\n                            weighted_overall_amount += record[1] * (\n                                Mundus.now - usage_records[index - 1][0]\n                            )\n                        else:\n                            weighted_overall_amount += record[1] * (\n                                record[0] - usage_records[index - 1][0]\n                            )\n                    return (\n                        1\n                        - (weighted_overall_amount / (usage_records[-1][0] - after))\n                        / self.capacity\n                    )\n        else:\n            return 1 - (self.amount / self.capacity)\n\n    def usage(self, duration: int | float | Callable | None = None):\n        \"\"\"Return the usage ( occupied amount ) of the resource in the duration.\n\n        Args:\n            duration (int | float | Callable | None, optional): the duration to trace back in time. Defaults to None.\n        \"\"\"\n        return self.capacity * self.utilization(duration)\n\n    @property\n    def amount(self) -&gt; int | float:\n        \"\"\"Return the current available amount of the resource.\"\"\"\n        return self._amount\n\n    @property\n    def capacity(self) -&gt; int | float:\n        \"\"\"Return the capacity of the resource.\"\"\"\n        return self._capacity\n\n    @property\n    def occupied(self) -&gt; int | float:\n        \"\"\"Return the current occupied amount of the resource.\"\"\"\n        return self.capacity - self.amount\n\n    @property\n    def label(self) -&gt; str | None:\n        \"\"\"Return the label of the resource.\"\"\"\n        return self._label\n\n    @property\n    def user_records(self) -&gt; List[Tuple[object, int | float]]:\n        \"\"\"Return the usage records of the resource per user.\"\"\"\n        return self._user_records\n\n    @property\n    def usage_records(self) -&gt; List[Tuple[int | float, int | float]]:\n        \"\"\"Return the usage records of the resource, for calculating the usage of the resource in a duration.\"\"\"\n        return self._usage_records\n\n    @property\n    def users(self) -&gt; List[object]:\n        \"\"\"Return the users of the resource.\"\"\"\n        return [record[0] for record in self._user_records]\n</code></pre>"},{"location":"api/resource/#Akatosh.resource.Resource.amount","title":"<code>amount: int | float</code>  <code>property</code>","text":"<p>Return the current available amount of the resource.</p>"},{"location":"api/resource/#Akatosh.resource.Resource.capacity","title":"<code>capacity: int | float</code>  <code>property</code>","text":"<p>Return the capacity of the resource.</p>"},{"location":"api/resource/#Akatosh.resource.Resource.label","title":"<code>label: str | None</code>  <code>property</code>","text":"<p>Return the label of the resource.</p>"},{"location":"api/resource/#Akatosh.resource.Resource.occupied","title":"<code>occupied: int | float</code>  <code>property</code>","text":"<p>Return the current occupied amount of the resource.</p>"},{"location":"api/resource/#Akatosh.resource.Resource.usage_records","title":"<code>usage_records: List[Tuple[int | float, int | float]]</code>  <code>property</code>","text":"<p>Return the usage records of the resource, for calculating the usage of the resource in a duration.</p>"},{"location":"api/resource/#Akatosh.resource.Resource.user_records","title":"<code>user_records: List[Tuple[object, int | float]]</code>  <code>property</code>","text":"<p>Return the usage records of the resource per user.</p>"},{"location":"api/resource/#Akatosh.resource.Resource.users","title":"<code>users: List[object]</code>  <code>property</code>","text":"<p>Return the users of the resource.</p>"},{"location":"api/resource/#Akatosh.resource.Resource.__init__","title":"<code>__init__(capacity, initial_amount=None, label=None)</code>","text":"<p>Resource is a class that represents a resource with capacity and amount, any object can use this resource by calling distribute() and return by calling collect() methods.</p> <p>Parameters:</p> Name Type Description Default <code>capacity</code> <code>int | float | Callable</code> <p>the capacity of the resource.</p> required <code>initial_amount</code> <code>int | float | Callable | None</code> <p>the initial amount of the resource. Defaults to capacity.</p> <code>None</code> <code>label</code> <code>str | None</code> <p>short description of the resource. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>raise if initial amount is greater than capacity.</p> Source code in <code>Akatosh\\resource.py</code> <pre><code>def __init__(\n    self,\n    capacity: int | float | Callable,\n    initial_amount: int | float | Callable | None = None,\n    label: str | None = None,\n) -&gt; None:\n    \"\"\"Resource is a class that represents a resource with capacity and amount, any object can use this resource by calling distribute() and return by calling collect() methods.\n\n    Args:\n        capacity (int | float | Callable): the capacity of the resource.\n        initial_amount (int | float | Callable | None, optional): the initial amount of the resource. Defaults to capacity.\n        label (str | None, optional): short description of the resource. Defaults to None.\n\n    Raises:\n        ValueError: raise if initial amount is greater than capacity.\n    \"\"\"\n    if callable(capacity):\n        self._capacity = capacity()\n    else:\n        self._capacity = capacity\n    if initial_amount:\n        if callable(initial_amount):\n            if initial_amount() &gt; self.capacity:\n                raise ValueError(\"Initial amount is greater than capacity.\")\n            else:\n                self._amount = initial_amount()\n        else:\n            if initial_amount &gt; self.capacity:\n                raise ValueError(\"Initial amount is greater than capacity.\")\n            else:\n                self._amount = initial_amount\n    else:\n        self._amount = self.capacity\n    self._label = label\n    self._user_records: List[\n        Tuple[object, int | float]\n    ] = list()  # (user, amount) tracking the usage of individual user\n    self._usage_records: List[\n        Tuple[int | float, int | float]\n    ] = list()  # (time, amount) tracking the usage of the resource over time\n</code></pre>"},{"location":"api/resource/#Akatosh.resource.Resource.collect","title":"<code>collect(user, amount=None)</code>","text":"<p>Collect the amount of resource from the user.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>object</code> <p>the user of the resource.</p> required <code>amount</code> <code>int | float | None</code> <p>the amount of resource to collect. Defaults to None means collecting all resource used by the user.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>raise if user is not using the resource or amount is greater than the current used amount of resource.</p> Source code in <code>Akatosh\\resource.py</code> <pre><code>def collect(self, user: object, amount: int | float | None = None) -&gt; None:\n    \"\"\"Collect the amount of resource from the user.\n\n    Args:\n        user (object): the user of the resource.\n        amount (int | float | None, optional): the amount of resource to collect. Defaults to None means collecting all resource used by the user.\n\n    Raises:\n        ValueError: raise if user is not using the resource or amount is greater than the current used amount of resource.\n    \"\"\"\n    if user not in self.users:\n        raise ValueError(f\"User {user} is not using Resource {self.label}.\")\n    if amount is None:\n        for index, record in enumerate(self.user_records):\n            if record[0] is user:\n                self._amount += record[1]\n                self.usage_records.append((Mundus.now, self.amount))\n                logger.debug(\n                    f\"Resource {self.label} collected {record[1]} from {user}.\"\n                )\n                break\n    else:\n        for index, record in enumerate(self.user_records):\n            if record[0] is user:\n                if record[1] &lt; amount:\n                    raise ValueError(\n                        f\"{user} occupied {record[1]} of Resource {self.label}, less than {amount}.\"\n                    )\n                else:\n                    self.user_records[index] = (user, record[1] - amount)\n                    if self.user_records[index][1] == 0:\n                        self.user_records.pop(index)\n                    self._amount += amount\n                    self.usage_records.append((Mundus.now, self.amount))\n                    logger.debug(\n                        f\"Resource {self.label} collected {amount} from {user}.\"\n                    )\n                    break\n</code></pre>"},{"location":"api/resource/#Akatosh.resource.Resource.distribute","title":"<code>distribute(user, amount)</code>","text":"<p>Distribute the amount of resource to the user.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>object</code> <p>the user of the resource.</p> required <code>amount</code> <code>int | float</code> <p>the amount of resource to distribute.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>raise if amount is greater than the current available amount of resource.</p> Source code in <code>Akatosh\\resource.py</code> <pre><code>def distribute(self, user: object, amount: int | float) -&gt; None:\n    \"\"\"Distribute the amount of resource to the user.\n\n    Args:\n        user (object): the user of the resource.\n        amount (int | float): the amount of resource to distribute.\n\n    Raises:\n        ValueError: raise if amount is greater than the current available amount of resource.\n    \"\"\"\n    if amount &gt; self.amount:\n        raise ValueError(f\"Not enough amount in Resource {self.label}.\")\n    else:\n        self._amount -= amount\n        if user in self.users:\n            for index, record in enumerate(self.user_records):\n                if record[0] is user:\n                    self.user_records[index] = (user, record[1] + amount)\n                    break\n        else:\n            self.user_records.append((user, amount))\n        self.usage_records.append((Mundus.now, self.amount))\n        logger.debug(f\"Resource {self.label} distributed {amount} to {user}.\")\n</code></pre>"},{"location":"api/resource/#Akatosh.resource.Resource.get","title":"<code>get(amount)</code>","text":"<p>Get the amount of resource from the resource.</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>int | float</code> <p>the amount of resource to get.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>raise if amount is greater than the current available amount of resource.</p> Source code in <code>Akatosh\\resource.py</code> <pre><code>def get(self, amount: int | float) -&gt; None:\n    \"\"\"Get the amount of resource from the resource.\n\n    Args:\n        amount (int | float): the amount of resource to get.\n\n    Raises:\n        ValueError: raise if amount is greater than the current available amount of resource.\n    \"\"\"\n    if amount &gt; self.amount:\n        raise ValueError(f\"Not enough amount in Resource {self.label}.\")\n    else:\n        self._amount -= amount\n        self.usage_records.append((Mundus.now, self.amount))\n</code></pre>"},{"location":"api/resource/#Akatosh.resource.Resource.put","title":"<code>put(amount)</code>","text":"<p>Put the amount of resource back to the resource.</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>int | float</code> <p>the amount of resource to put.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>raise if amount is greater than the current used amount of resource.</p> Source code in <code>Akatosh\\resource.py</code> <pre><code>def put(self, amount: int | float) -&gt; None:\n    \"\"\"Put the amount of resource back to the resource.\n\n    Args:\n        amount (int | float): the amount of resource to put.\n\n    Raises:\n        ValueError: raise if amount is greater than the current used amount of resource.\n    \"\"\"\n    if amount &gt; self.occupied:\n        raise ValueError(f\"Not enough capacity in Resource {self.label}.\")\n    else:\n        self._amount += amount\n        self.usage_records.append((Mundus.now, self.amount))\n</code></pre>"},{"location":"api/resource/#Akatosh.resource.Resource.usage","title":"<code>usage(duration=None)</code>","text":"<p>Return the usage ( occupied amount ) of the resource in the duration.</p> <p>Parameters:</p> Name Type Description Default <code>duration</code> <code>int | float | Callable | None</code> <p>the duration to trace back in time. Defaults to None.</p> <code>None</code> Source code in <code>Akatosh\\resource.py</code> <pre><code>def usage(self, duration: int | float | Callable | None = None):\n    \"\"\"Return the usage ( occupied amount ) of the resource in the duration.\n\n    Args:\n        duration (int | float | Callable | None, optional): the duration to trace back in time. Defaults to None.\n    \"\"\"\n    return self.capacity * self.utilization(duration)\n</code></pre>"},{"location":"api/resource/#Akatosh.resource.Resource.utilization","title":"<code>utilization(duration=None)</code>","text":"<p>Return the utilization ( occupied amount / capacity ) of the resource in the duration.</p> <p>Parameters:</p> Name Type Description Default <code>duration</code> <code>int | float | Callable | None</code> <p>the duration to trace back in time. Defaults to None.</p> <code>None</code> Source code in <code>Akatosh\\resource.py</code> <pre><code>def utilization(self, duration: int | float | Callable | None = None):\n    \"\"\"Return the utilization ( occupied amount / capacity ) of the resource in the duration.\n\n    Args:\n        duration (int | float | Callable | None, optional): the duration to trace back in time. Defaults to None.\n    \"\"\"\n    if duration:\n        if callable(duration):\n            after = Mundus.now - duration()\n        else:\n            after = Mundus.now - duration\n        if after &lt; 0:\n            after = 0\n        usage_records = [\n            usage_record\n            for usage_record in self.usage_records\n            if usage_record[0] &gt;= after\n        ]\n        if len(usage_records) == 0:\n            return 1 - (self.amount / self.capacity)\n        else:\n            if usage_records[-1][0] - after == 0:\n                return 1 - (usage_records[-1][1] / self.capacity)\n            else:\n                weighted_overall_amount = 0\n                for index, record in enumerate(usage_records):\n                    if index == 0:\n                        weighted_overall_amount += record[1] * (record[0] - after)\n                    elif index == len(usage_records) - 1:\n                        weighted_overall_amount += record[1] * (\n                            Mundus.now - usage_records[index - 1][0]\n                        )\n                    else:\n                        weighted_overall_amount += record[1] * (\n                            record[0] - usage_records[index - 1][0]\n                        )\n                return (\n                    1\n                    - (weighted_overall_amount / (usage_records[-1][0] - after))\n                    / self.capacity\n                )\n    else:\n        return 1 - (self.amount / self.capacity)\n</code></pre>"},{"location":"api/universe/","title":"Universe","text":""},{"location":"api/universe/#Akatosh.universe.Universe","title":"<code>Universe</code>","text":"Source code in <code>Akatosh\\universe.py</code> <pre><code>class Universe:\n    def __init__(self) -&gt; None:\n        \"\"\"The Simulation Universe.\"\"\"\n        self._resolution = 15  # the resolution of the time. 1 means minimum time unit is 0.1 second.\n        self._now: int | float = -1  # the current time of the simulated universe.\n        self._future_events: List[Event] = list()  # the future events queue.\n        self._current_events: List[Event] = list()  # the current events queue.\n        self._past_events: List[Event] = list()  # the past events queue.\n        self._alduin: bool = False  # trigger to stop the simulation.\n        self.set_logger(logging.ERROR)  # set the default logger level to ERROR.\n\n    async def akatosh(self, till: int | float | None = None):\n        \"\"\"Akatosh is the god of time in the Elder Scrolls universe. This method is the core of the simulation.\n\n        Args:\n            till (int | float | None, optional): the end time of the simulated universe. Defaults to None.\n\n        Raises:\n            RuntimeError: raise if the event is in unknown state or being placed in wrong event queue.\n        \"\"\"\n        while len(self.future_events) != 0:\n\n            # stop simulation if world eater alduin is triggered.\n            if self.alduin:\n                return\n\n            # update the current time of the simulated universe.\n            valid_future_events = [\n                event\n                for event in self.future_events\n                if event.state == State.ACTIVE or event.state == State.INACTIVE\n            ]\n            if len(valid_future_events) == 0:\n                return\n            _time = min(event.at for event in valid_future_events)\n            if self.now &lt; _time:\n                self._now = _time\n\n            # stop simulation if the end time is reached.\n            if till is not None:\n                if self.now &gt; till:\n                    return\n\n            logger.debug(f\"Time: {self.now}\")\n\n            logger.debug(\n                f\"Future active events: {[(event.at, event.label) for event in self.future_events]}\"\n            )\n\n            self.organise_events()\n\n            logger.debug(\n                f\"Current events: {[(event.priority, event.label) for event in self.current_events]}\"\n            )\n\n            await self.execute_current_events()\n\n\n\n    def organise_events(self):\n        \"\"\"Organise the events in the future events queue. Valid event will be moved to the current events queue. Non-valid event will be moved to the past events queue.\n\n        Raises:\n            RuntimeError: raise if the event is in unknown state or being placed in wrong event queue.\n        \"\"\"\n        for event in self.future_events[:]:\n            if event.at &lt;= self.now:\n                if event.state == State.ACTIVE or event.state == State.INACTIVE:\n                    logger.debug(f\"Event {event.label} is triggered.\")\n                    self.future_events.remove(event)\n                    self.current_events.append(event)\n                elif event.state == State.CANCELED:\n                    raise RuntimeError(\n                            f\"Event {event.label} is canceled but inside future events queue.\"\n                        )\n                elif event.state == State.ENDED:\n                    raise RuntimeError(\n                            f\"Event {event.label} is ended but inside future events queue.\"\n                        )\n                else:\n                    raise RuntimeError(f\"Event {event.label} is in unknown state.\")\n\n    async def execute_current_events(self):\n        \"\"\"Execute the current events queue based on priority. The event with the lowest priority will be executed first. The event with the same priority will be executed concurrently.\n        \"\"\"\n        while (\n            len([event for event in self.current_events if event.state == State.ACTIVE])\n            != 0\n        ):\n            priority = min(\n                event.priority\n                for event in self.current_events\n                if event.state == State.ACTIVE\n            )\n            logger.debug(\n                f\"Current Priority: {priority}, Executing events: {[event.label for event in self.current_events if event.priority == priority]}\"\n            )\n            await asyncio.gather(\n                *[\n                    event._perform()\n                    for event in self.current_events\n                    if event.priority == priority\n                ]\n            )\n\n    def simulate(self, till: int | float | None = None):\n        \"\"\"Start the simulation.\"\"\"\n        asyncio.run(self.akatosh(till))\n\n    def set_logger(self, level: int):\n        \"\"\"Set the logger level.\"\"\"\n        logger.setLevel(level)\n\n    @property\n    def resolution(self) -&gt; int:\n        \"\"\"Return  the resolution of the time.\"\"\"\n        return self._resolution\n\n    @resolution.setter\n    def resolution(self, value: int):\n        \"\"\"Set the resolution of the time.\"\"\"\n        if value &lt;= 0:\n            raise ValueError(\"Resolution must be greater than 0.\")\n        self._resolution = value\n\n    @property\n    def now(self) -&gt; int | float:\n        \"\"\"Return the current time of the simulated universe.\"\"\"\n        return self._now\n\n    @property\n    def future_events(self) -&gt; List[Event]:\n        \"\"\"Return the future events queue.\"\"\"\n        return self._future_events\n\n    @property\n    def current_events(self) -&gt; List[Event]:\n        \"\"\"Return the current events queue.\"\"\"\n        return self._current_events\n\n    @property\n    def past_events(self) -&gt; List[Event]:\n        \"\"\"Return the past events queue.\"\"\"\n        return self._past_events\n\n    @property\n    def alduin(self) -&gt; bool:\n        \"\"\"Return the trigger to stop the simulation.\"\"\"\n        return self._alduin\n\n    @alduin.setter\n    def alduin(self, value: bool):\n        \"\"\"Set the trigger to stop the simulation.\"\"\"\n        self._alduin = value\n</code></pre>"},{"location":"api/universe/#Akatosh.universe.Universe.alduin","title":"<code>alduin: bool</code>  <code>property</code> <code>writable</code>","text":"<p>Return the trigger to stop the simulation.</p>"},{"location":"api/universe/#Akatosh.universe.Universe.current_events","title":"<code>current_events: List[Event]</code>  <code>property</code>","text":"<p>Return the current events queue.</p>"},{"location":"api/universe/#Akatosh.universe.Universe.future_events","title":"<code>future_events: List[Event]</code>  <code>property</code>","text":"<p>Return the future events queue.</p>"},{"location":"api/universe/#Akatosh.universe.Universe.now","title":"<code>now: int | float</code>  <code>property</code>","text":"<p>Return the current time of the simulated universe.</p>"},{"location":"api/universe/#Akatosh.universe.Universe.past_events","title":"<code>past_events: List[Event]</code>  <code>property</code>","text":"<p>Return the past events queue.</p>"},{"location":"api/universe/#Akatosh.universe.Universe.resolution","title":"<code>resolution: int</code>  <code>property</code> <code>writable</code>","text":"<p>Return  the resolution of the time.</p>"},{"location":"api/universe/#Akatosh.universe.Universe.__init__","title":"<code>__init__()</code>","text":"<p>The Simulation Universe.</p> Source code in <code>Akatosh\\universe.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"The Simulation Universe.\"\"\"\n    self._resolution = 15  # the resolution of the time. 1 means minimum time unit is 0.1 second.\n    self._now: int | float = -1  # the current time of the simulated universe.\n    self._future_events: List[Event] = list()  # the future events queue.\n    self._current_events: List[Event] = list()  # the current events queue.\n    self._past_events: List[Event] = list()  # the past events queue.\n    self._alduin: bool = False  # trigger to stop the simulation.\n    self.set_logger(logging.ERROR)  # set the default logger level to ERROR.\n</code></pre>"},{"location":"api/universe/#Akatosh.universe.Universe.akatosh","title":"<code>akatosh(till=None)</code>  <code>async</code>","text":"<p>Akatosh is the god of time in the Elder Scrolls universe. This method is the core of the simulation.</p> <p>Parameters:</p> Name Type Description Default <code>till</code> <code>int | float | None</code> <p>the end time of the simulated universe. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>raise if the event is in unknown state or being placed in wrong event queue.</p> Source code in <code>Akatosh\\universe.py</code> <pre><code>async def akatosh(self, till: int | float | None = None):\n    \"\"\"Akatosh is the god of time in the Elder Scrolls universe. This method is the core of the simulation.\n\n    Args:\n        till (int | float | None, optional): the end time of the simulated universe. Defaults to None.\n\n    Raises:\n        RuntimeError: raise if the event is in unknown state or being placed in wrong event queue.\n    \"\"\"\n    while len(self.future_events) != 0:\n\n        # stop simulation if world eater alduin is triggered.\n        if self.alduin:\n            return\n\n        # update the current time of the simulated universe.\n        valid_future_events = [\n            event\n            for event in self.future_events\n            if event.state == State.ACTIVE or event.state == State.INACTIVE\n        ]\n        if len(valid_future_events) == 0:\n            return\n        _time = min(event.at for event in valid_future_events)\n        if self.now &lt; _time:\n            self._now = _time\n\n        # stop simulation if the end time is reached.\n        if till is not None:\n            if self.now &gt; till:\n                return\n\n        logger.debug(f\"Time: {self.now}\")\n\n        logger.debug(\n            f\"Future active events: {[(event.at, event.label) for event in self.future_events]}\"\n        )\n\n        self.organise_events()\n\n        logger.debug(\n            f\"Current events: {[(event.priority, event.label) for event in self.current_events]}\"\n        )\n\n        await self.execute_current_events()\n</code></pre>"},{"location":"api/universe/#Akatosh.universe.Universe.execute_current_events","title":"<code>execute_current_events()</code>  <code>async</code>","text":"<p>Execute the current events queue based on priority. The event with the lowest priority will be executed first. The event with the same priority will be executed concurrently.</p> Source code in <code>Akatosh\\universe.py</code> <pre><code>async def execute_current_events(self):\n    \"\"\"Execute the current events queue based on priority. The event with the lowest priority will be executed first. The event with the same priority will be executed concurrently.\n    \"\"\"\n    while (\n        len([event for event in self.current_events if event.state == State.ACTIVE])\n        != 0\n    ):\n        priority = min(\n            event.priority\n            for event in self.current_events\n            if event.state == State.ACTIVE\n        )\n        logger.debug(\n            f\"Current Priority: {priority}, Executing events: {[event.label for event in self.current_events if event.priority == priority]}\"\n        )\n        await asyncio.gather(\n            *[\n                event._perform()\n                for event in self.current_events\n                if event.priority == priority\n            ]\n        )\n</code></pre>"},{"location":"api/universe/#Akatosh.universe.Universe.organise_events","title":"<code>organise_events()</code>","text":"<p>Organise the events in the future events queue. Valid event will be moved to the current events queue. Non-valid event will be moved to the past events queue.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>raise if the event is in unknown state or being placed in wrong event queue.</p> Source code in <code>Akatosh\\universe.py</code> <pre><code>def organise_events(self):\n    \"\"\"Organise the events in the future events queue. Valid event will be moved to the current events queue. Non-valid event will be moved to the past events queue.\n\n    Raises:\n        RuntimeError: raise if the event is in unknown state or being placed in wrong event queue.\n    \"\"\"\n    for event in self.future_events[:]:\n        if event.at &lt;= self.now:\n            if event.state == State.ACTIVE or event.state == State.INACTIVE:\n                logger.debug(f\"Event {event.label} is triggered.\")\n                self.future_events.remove(event)\n                self.current_events.append(event)\n            elif event.state == State.CANCELED:\n                raise RuntimeError(\n                        f\"Event {event.label} is canceled but inside future events queue.\"\n                    )\n            elif event.state == State.ENDED:\n                raise RuntimeError(\n                        f\"Event {event.label} is ended but inside future events queue.\"\n                    )\n            else:\n                raise RuntimeError(f\"Event {event.label} is in unknown state.\")\n</code></pre>"},{"location":"api/universe/#Akatosh.universe.Universe.set_logger","title":"<code>set_logger(level)</code>","text":"<p>Set the logger level.</p> Source code in <code>Akatosh\\universe.py</code> <pre><code>def set_logger(self, level: int):\n    \"\"\"Set the logger level.\"\"\"\n    logger.setLevel(level)\n</code></pre>"},{"location":"api/universe/#Akatosh.universe.Universe.simulate","title":"<code>simulate(till=None)</code>","text":"<p>Start the simulation.</p> Source code in <code>Akatosh\\universe.py</code> <pre><code>def simulate(self, till: int | float | None = None):\n    \"\"\"Start the simulation.\"\"\"\n    asyncio.run(self.akatosh(till))\n</code></pre>"},{"location":"examples/cancel_event/","title":"Cancel Event","text":"<pre><code>import logging\n\nfrom Akatosh import InstantEvent, event, Mundus\n\n# define the event function\ndef hellow_world():\n    print(f\"{Mundus.now}:\\tHello World!\")\n\n# create a event occurs at 5s\nlater_event = InstantEvent(at=5, action=hellow_world)\n\n# create a event  occurs at 3s to cancel the above event at 5s\n@event(at=3, label=\"cancel\")\ndef resume():\n    print(f\"{Mundus.now}:\\tCancel future event.\")\n    later_event.cancel()\n\n# enable debug message\nMundus.set_logger(logging.DEBUG)\n\n# run the simulation\nMundus.simulate()\n</code></pre>"},{"location":"examples/continuous_event/","title":"Continuous Event","text":"<pre><code>import random\nfrom Akatosh import ContinuousEvent, Mundus, continuous_event\nimport logging\n\n# define a function for first continuous event\ndef action():\n    print(f\"Hello World at {Mundus.now} from Test 1\")\n\n# create a continuous event start at 0s and last 10s\nevent = ContinuousEvent(\n    at=0, interval=random.random(), duration=10, action=action, label=\"Test\"\n)\n\n# define a function for second continuous event\ndef action2():\n    print(f\"Hello World at {Mundus.now} from Test 2\")\n\n# create a continuous event start at 0s and last 15s but with the first event as precursor\nevent2 = ContinuousEvent(\n    at=0,\n    interval=random.random(),\n    duration=15,\n    action=action2,\n    label=\"Test2\",\n    priority=-1,\n    precursor=event,\n)\n\n# create a third continuous event with decorator\n@continuous_event(at=0, interval=random.random(), duration=15, label=\"Test3\")\ndef action3():\n    print(f\"Hello World at {Mundus.now} from Test 3\")\n\n# enable debug message\nMundus.set_logger(logging.DEBUG)\n\n# run simulation\nMundus.simulate()\n</code></pre>"},{"location":"examples/create_event_within_event/","title":"Create Event within Event","text":"<pre><code>import logging\n\nfrom Akatosh import event, Mundus\n\n# create a instant event at simulation time 1.0s\n@event(at=1)\ndef hellow_world():\n    print(f\"{Mundus.now}:\\tHello World!\")\n\n    # this instant event create anothe instant event at simulation time 5.0s\n    @event(at=5)\n    def hellow_world_again():\n        print(f\"{Mundus.now}:\\tHello World! Again!\")\n\n# enable debug message\nMundus.set_logger(logging.DEBUG)\n\n# simulate\nMundus.simulate()\n</code></pre>"},{"location":"examples/entity/","title":"Entity","text":"<pre><code>import logging\n\nfrom Akatosh import Entity, Mundus, Resource, event\n\n# define a simple test enity\nclass TestEntity(Entity):\n\n    # implement the callback function upon creation\n    def on_creation(self):\n        print(f\"Entity {self.label} created\")\n\n    # implement the callback function upon termination\n    def on_termination(self):\n        print(f\"Entity {self.label} terminated\")\n\n# create the test entity\ntest_entity = TestEntity(label=\"Test Entity\", create_at=0, terminate_at=10)\n\n# create a simple resource\ntest_resource = Resource(label=\"Test Resource\", capacity=1)\n\n# create a simple  instant event to occupy the resource\n@event(at=2, label=\"Test Event Get Resource\")\ndef test_event():\n    test_entity.get(test_resource, 1)\n\n# enable debug message\nMundus.set_logger(logging.DEBUG)\n\n# run the simulation\nMundus.simulate()\n</code></pre>"},{"location":"examples/entity_after_entity/","title":"Entity after another Entity","text":"<pre><code>import logging\n\nfrom Akatosh import Entity, Mundus, Resource, instant_event\n\n# define a simple entity\nclass TestEntity(Entity):\n    def on_creation(self):\n        print(f\"Entity {self.label} created\")\n\n    def on_termination(self):\n        print(f\"Entity {self.label} terminated\")\n\n# create first entity at 0s and terminate at 10s\ntest_entity_1 = TestEntity(label=\"Test Entity 1\", create_at=0, terminate_at=10)\n\n# create second entity at 0s and terminate at 12s but after first entity\ntest_entity_2 = TestEntity(label=\"Test Entity 2\", create_at=0, terminate_at=12, precursor=test_entity_1)\n\n\n\nMundus.set_logger(logging.DEBUG)\nMundus.simulate()\n\nprint(test_entity_2.created_at, test_entity_2.terminated_at)\n</code></pre>"},{"location":"examples/entity_events_entitylist/","title":"Entity, Events and EntityList","text":"<pre><code>import logging\nfrom Akatosh import Entity, EntityList, Mundus\n\n# create an entity list\nelist = EntityList([])\n\n# create an test entity\ntest_entity = Entity(label=\"test_entity\", create_at=0, terminate_at=3)\n\n# test entity engage an instant event that append itself to the entity list\n@test_entity.instant_event(at=2, label=\"Append Entity List\")\ndef action2():\n    elist.append(test_entity)\n\n# test entity engage an continuous event that print the entity list\n@test_entity.continuous_event(at=1, interval=1, duration=5, label=\"Test Entity List - Continuous\")\ndef test_action():\n    print(f\"{elist}\")\n\n# enable the debug message\nMundus.set_logger(logging.DEBUG)\n\n# run the simulation\nMundus.simulate()\n</code></pre>"},{"location":"examples/event_priority/","title":"Event Priority","text":"<pre><code>import logging\n\nfrom Akatosh import event, Mundus\n\n# create a event with priority 2\n@event(at=0, priority=2, label=\"AuPost\")\ndef au_post():\n    print(f\"{Mundus.now}:\\tAuPost deliver!\")\n\n# create a event with priority 1\n@event(at=0, priority=1, label=\"StarTrek\")\ndef star_trek():\n    print(f\"{Mundus.now}:\\tStar Trek deliver!\")\n\n\nMundus.set_logger(logging.DEBUG)\nMundus.simulate()\n# the Star Trek will deliver first, AuPost sucks!\n</code></pre>"},{"location":"examples/event_wait_event/","title":"Event After Another Event","text":"<pre><code>import logging\n\nfrom Akatosh import event, Mundus, InstantEvent\n\n# define the actual function of the event\ndef hellow_world():\n    print(f\"{Mundus.now}:\\tHello World!\")\n\n# create a instant event at simulation time 5s\ne = InstantEvent(at=5, action=hellow_world, label=\"Hello World\")\n\n# create a instant event at simulation time 1s, but set the above event as precursor. \n# So this event will be triggered at 1s but not executed until above event is done.\n@event(at=0, precursor=e, label=\"Hello World Again\")\nasync def hellow_world_again():\n    print(f\"{Mundus.now}:\\tHello World! Again!\")\n\n# enable debug message\nMundus.set_logger(logging.DEBUG)\n\n# run the simulate\nMundus.simulate()\n</code></pre>"},{"location":"examples/instant_event/","title":"Instant Event","text":"<pre><code>import logging\n\nfrom Akatosh import event, Mundus\n\n# create an instant event at simulation time 5.0s, print \"Hello World Again!\"\n@event(at=5)\ndef hellow_world_again():\n    print(f\"{Mundus.now}:\\tHello World! Again!\")\n\n# create an instant event at simulation time 1.0s, print \"Hello World!\"\n@event(at=1)\ndef hellow_world():\n    print(f\"{Mundus.now}:\\tHello World!\")\n\n# enable debug message\nMundus.set_logger(logging.DEBUG)\n\n# simulate\nMundus.simulate()\n</code></pre>"},{"location":"examples/pause_event/","title":"Pause Event","text":"<pre><code>import logging\n\nfrom Akatosh import InstantEvent, event, Mundus\n\n# create a event that should occur at 5.0s\ndef hellow_world():\n    print(f\"{Mundus.now}:\\tHello World!\")\nlater_event = InstantEvent(at=5, action=hellow_world)\n\n# create a event to resume the later event.\n@event(at=3, label=\"resume\")\ndef resume():\n    print(f\"{Mundus.now}:\\tResume the future event.\")\n    later_event.activate()\n\n# create a event to pause the \"later_event\"\n@event(at=0, label=\"pause\")\ndef pause():\n    print(f\"{Mundus.now}:\\tPause the future event.\")\n    later_event.deactivate()\n\n# enable debug message\nMundus.set_logger(logging.DEBUG)\n\n# run the simulation\nMundus.simulate()\n</code></pre>"},{"location":"examples/resource/","title":"Resource","text":"<pre><code>from Akatosh import Resource, event, Mundus\n\n# create a resource with capacity 100\nres = Resource(100, label=\"test\")\n\nfor i in range(10):\n    # get 10 units per second for 10s\n    @event(at=i, label=f\"consumer{i}\")\n    def consumer():\n        res.get(10)\n        print(f\"{Mundus.now} get {res.amount}, current usage {res.usage()}\")\n\n\nfor i in range(5):\n    # put 10 units per second for first 5s\n    @event(at=i, label=f\"producer{i}\")\n    def consumer():\n        res.put(10)\n        print(f\"{Mundus.now} put {res.amount}, current usage {res.usage()}\")\n\n\nfor i in range(10):\n    # report the usage every second for 10s, tracing back for 2s\n    @event(at=i, label=f\"producer{i}\")\n    def consumer():\n        print(f\"{Mundus.now} past 2s usage {res.usage(2)}\")\n\n# run the simulation\nMundus.simulate()\n</code></pre>"}]}