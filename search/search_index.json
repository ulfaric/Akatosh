{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Akatosh","text":"<p><code>Akatosh</code> is a light-weighted disceret event simulation library. Unlike popular library <code>Simpy</code> which is progress-oriented and you have to write generator function for simulated events or events interaction, <code>Akatosh</code> is fully object-oriented that events are encapsulated as <code>Event</code> with states and priority. The actual impact of events are simply regular python functions ( or async function ). You could create events all at once, or create event within event. In addition, <code>Akatosh</code> is async which means event that are happening at the same simulated time will be executed simultaneously for real, unless they have different priority.</p> <p><code>Akatosh</code> also support <code>Resource</code>, provide all functionalities as it is in <code>Simpy</code> with extra utilities for telemetries collection and interaction with <code>Entity</code>. The <code>Entity</code> is unique to <code>Akatosh</code> which represents a abstract entity with a life-cycle, for example a follower NPC. The <code>Entity</code> supports utility functions to interact with <code>Resource</code> and automatically releases all its occupied resources upon termination.</p> <p>You probably already noticed that <code>Akatosh</code> is the name of \"Dragon God of Time\" in elder scroll serie, therefore the singleton class <code>Mundus</code> is the core of the simulation. The <code>Mundus</code> will schedule the events, move forward time and engage async execution.</p>"},{"location":"#real-time","title":"Real Time","text":"<p>Since version 3.0.0+, <code>Akatosh</code> also supports for real time simulation with time step of 0.1s. Real time simulation can be simply enabled by <code>Mundus.enable_realtime()</code>. Please note that due to async event loop overhead, there is about 10% delay from all time steps.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<p>To use <code>Akatosh</code>:</p> <pre><code>pip install -U Akatosh\n</code></pre> <p>A basic example is showing below, for more information please look at Examples and API Reference, full documentation is available at https://ulfaric.github.io/Akatosh/.</p> <pre><code>import asyncio\nfrom Akatosh.universe import universe\nfrom Akatosh.resource import Resource\nfrom Akatosh.entity import Entity\nfrom Akatosh.event import Event\n\n# create a resource with capacity of 100 and current level 50\nres = Resource(100.0, 50.0)\n\n# create a instance event happens at 0.9s\nlock = Event(0.9,0.9, lambda: print(\"Unlocked!\"))\n\n# indicate a user entity should be created after lock event ended, wait till 1.1s.\nuser = Entity(lock, 1.1, \"User\")\n\n# indicate user entity engage a event at 1.2s\n@user.event(1.2,1.2, \"Use Resource\")\ndef user_event():\n    if res.distribute(user, 1):\n        print(res.level)\n    else:\n        print(\"Not enough resource\")\n\n\n# run simulation for 1.2s\nasyncio.run(universe.simulate(1.2))\n</code></pre>"},{"location":"api/entity/","title":"Entity","text":"Source code in <code>Akatosh\\entity.py</code> <pre><code>class Entity:\n\n    def __init__(\n        self,\n        at: float | Event,\n        till: float | Event,\n        label: Optional[str] = None,\n        priority: int = 0,\n    ) -&gt; None:\n        \"\"\"Create an entity with a creation and termination event.\n\n        Args:\n            at (float | Event): when the entity is created.\n            till (float | Event): when the entity is terminated.\n            label (Optional[str], optional): short description to the entity. Defaults to None.\n            priority (int, optional): the priority of the entity, only impacts the creation and termination event. Defaults to 0.\n        \"\"\"\n        self._label = label\n        self._at = at\n        self._till = till\n        self._created = False\n        self._terminated = False\n        self._priority = priority\n\n        # create an instant creation event\n        self._creation = Event(\n            at=at,\n            till=till,\n            action=self._create,\n            label=f\"{self} Creation\",\n            once=True,\n            priority=self.priority,\n        )\n        self._termination = Event(\n            at=till,\n            till=till,\n            action=self._terminate,\n            label=f\"{self} Termination\",\n            once=True,\n            priority=self.priority,\n        )\n\n        # create a queue for engaged events\n        self._events: List[Event] = list()\n\n        # create a queue for acquired resources\n        self._occupied_resources: List[Resource] = list()\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return the label of the entity if it exists, otherwise return the id of the entity.\"\"\"\n        if self.label is None:\n            return f\"Entity {id(self)}\"\n        return self.label\n\n    def _create(self):\n        \"\"\"Called when the entity is created.\"\"\"\n        self._created = True\n        logger.debug(f\"Entity {self} created.\")\n\n    def _terminate(self):\n        \"\"\"Called when the entity is terminated.\"\"\"\n        self._terminated = True\n        for event in self.events:\n            event.cancel()\n        for resource in self.occupied_resources:\n            resource.collect(self, inf)\n        logger.debug(f\"Entity {self} terminated.\")\n\n    def event(\n        self,\n        at: float | Event,\n        till: float | Event,\n        step: float = Mundus.time_step,\n        label: Optional[str] = None,\n        once: bool = False,\n        priority: int = 0,\n    ):\n        \"\"\"Decorator to add an event to the entity.\"\"\"\n\n        def _event(action: Callable):\n\n            async def __event():\n\n                if self.terminated:\n                    logger.warn(f\"Entity {self} already terminated.\")\n                    return\n\n                while True:\n                    if not self.created:\n                        logger.warn(f\"Entity {self} not created yet.\")\n                        await asyncio.sleep(0)\n                    else:\n                        break\n\n                event = Event(\n                    at=at,\n                    till=till,\n                    step=step,\n                    action=action,\n                    label=label,\n                    once=once,\n                    priority=priority,\n                )\n                self.events.append(event)\n                logger.debug(f\"Event {event} added to entity {self}.\")\n\n            Event(\n                at=at, till=at, action=__event, label=f\"{label} Engagement\", once=True\n            )\n\n        return _event\n\n    def acquire(self, resource: Resource, amount: float) -&gt; bool:\n        \"\"\"Acquire a amount from the resource.\"\"\"\n        if resource.distribute(self, amount):\n            return True\n        else:\n            return False\n\n    def release(self, resource: Resource, amount: float) -&gt; bool:\n        \"\"\"Release a amount from the resource.\"\"\"\n        if resource.collect(self, amount):\n            return True\n        else:\n            return False\n\n    @property\n    def label(self):\n        \"\"\"Short description of the entity.\"\"\"\n        return self._label\n\n    @property\n    def created(self):\n        \"\"\"Return True if the entity is created, otherwise False.\"\"\"\n        return self._created\n\n    @property\n    def terminated(self):\n        \"\"\"Return True if the entity is terminated, otherwise False.\"\"\"\n        return self._terminated\n\n    @property\n    def events(self):\n        \"\"\"The events that the entity is engaged with.\"\"\"\n        return self._events\n\n    @property\n    def occupied_resources(self):\n        \"\"\"The resources that the entity is using.\"\"\"\n        return self._occupied_resources\n\n    @property\n    def priority(self):\n        \"\"\"The priority of the entity.\"\"\"\n        return self._priority\n\n    @property\n    def creation(self):\n        \"\"\"The creation event of the entity.\"\"\"\n        return self._creation\n\n    @property\n    def termination(self):\n        \"\"\"The termination event of the entity.\"\"\"\n        return self._termination\n</code></pre>"},{"location":"api/entity/#Akatosh.entity.Entity.created","title":"<code>created</code>  <code>property</code>","text":"<p>Return True if the entity is created, otherwise False.</p>"},{"location":"api/entity/#Akatosh.entity.Entity.creation","title":"<code>creation</code>  <code>property</code>","text":"<p>The creation event of the entity.</p>"},{"location":"api/entity/#Akatosh.entity.Entity.events","title":"<code>events</code>  <code>property</code>","text":"<p>The events that the entity is engaged with.</p>"},{"location":"api/entity/#Akatosh.entity.Entity.label","title":"<code>label</code>  <code>property</code>","text":"<p>Short description of the entity.</p>"},{"location":"api/entity/#Akatosh.entity.Entity.occupied_resources","title":"<code>occupied_resources</code>  <code>property</code>","text":"<p>The resources that the entity is using.</p>"},{"location":"api/entity/#Akatosh.entity.Entity.priority","title":"<code>priority</code>  <code>property</code>","text":"<p>The priority of the entity.</p>"},{"location":"api/entity/#Akatosh.entity.Entity.terminated","title":"<code>terminated</code>  <code>property</code>","text":"<p>Return True if the entity is terminated, otherwise False.</p>"},{"location":"api/entity/#Akatosh.entity.Entity.termination","title":"<code>termination</code>  <code>property</code>","text":"<p>The termination event of the entity.</p>"},{"location":"api/entity/#Akatosh.entity.Entity.__init__","title":"<code>__init__(at, till, label=None, priority=0)</code>","text":"<p>Create an entity with a creation and termination event.</p> <p>Parameters:</p> Name Type Description Default <code>at</code> <code>float | Event</code> <p>when the entity is created.</p> required <code>till</code> <code>float | Event</code> <p>when the entity is terminated.</p> required <code>label</code> <code>Optional[str]</code> <p>short description to the entity. Defaults to None.</p> <code>None</code> <code>priority</code> <code>int</code> <p>the priority of the entity, only impacts the creation and termination event. Defaults to 0.</p> <code>0</code> Source code in <code>Akatosh\\entity.py</code> <pre><code>def __init__(\n    self,\n    at: float | Event,\n    till: float | Event,\n    label: Optional[str] = None,\n    priority: int = 0,\n) -&gt; None:\n    \"\"\"Create an entity with a creation and termination event.\n\n    Args:\n        at (float | Event): when the entity is created.\n        till (float | Event): when the entity is terminated.\n        label (Optional[str], optional): short description to the entity. Defaults to None.\n        priority (int, optional): the priority of the entity, only impacts the creation and termination event. Defaults to 0.\n    \"\"\"\n    self._label = label\n    self._at = at\n    self._till = till\n    self._created = False\n    self._terminated = False\n    self._priority = priority\n\n    # create an instant creation event\n    self._creation = Event(\n        at=at,\n        till=till,\n        action=self._create,\n        label=f\"{self} Creation\",\n        once=True,\n        priority=self.priority,\n    )\n    self._termination = Event(\n        at=till,\n        till=till,\n        action=self._terminate,\n        label=f\"{self} Termination\",\n        once=True,\n        priority=self.priority,\n    )\n\n    # create a queue for engaged events\n    self._events: List[Event] = list()\n\n    # create a queue for acquired resources\n    self._occupied_resources: List[Resource] = list()\n</code></pre>"},{"location":"api/entity/#Akatosh.entity.Entity.__str__","title":"<code>__str__()</code>","text":"<p>Return the label of the entity if it exists, otherwise return the id of the entity.</p> Source code in <code>Akatosh\\entity.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return the label of the entity if it exists, otherwise return the id of the entity.\"\"\"\n    if self.label is None:\n        return f\"Entity {id(self)}\"\n    return self.label\n</code></pre>"},{"location":"api/entity/#Akatosh.entity.Entity.acquire","title":"<code>acquire(resource, amount)</code>","text":"<p>Acquire a amount from the resource.</p> Source code in <code>Akatosh\\entity.py</code> <pre><code>def acquire(self, resource: Resource, amount: float) -&gt; bool:\n    \"\"\"Acquire a amount from the resource.\"\"\"\n    if resource.distribute(self, amount):\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"api/entity/#Akatosh.entity.Entity.event","title":"<code>event(at, till, step=Mundus.time_step, label=None, once=False, priority=0)</code>","text":"<p>Decorator to add an event to the entity.</p> Source code in <code>Akatosh\\entity.py</code> <pre><code>def event(\n    self,\n    at: float | Event,\n    till: float | Event,\n    step: float = Mundus.time_step,\n    label: Optional[str] = None,\n    once: bool = False,\n    priority: int = 0,\n):\n    \"\"\"Decorator to add an event to the entity.\"\"\"\n\n    def _event(action: Callable):\n\n        async def __event():\n\n            if self.terminated:\n                logger.warn(f\"Entity {self} already terminated.\")\n                return\n\n            while True:\n                if not self.created:\n                    logger.warn(f\"Entity {self} not created yet.\")\n                    await asyncio.sleep(0)\n                else:\n                    break\n\n            event = Event(\n                at=at,\n                till=till,\n                step=step,\n                action=action,\n                label=label,\n                once=once,\n                priority=priority,\n            )\n            self.events.append(event)\n            logger.debug(f\"Event {event} added to entity {self}.\")\n\n        Event(\n            at=at, till=at, action=__event, label=f\"{label} Engagement\", once=True\n        )\n\n    return _event\n</code></pre>"},{"location":"api/entity/#Akatosh.entity.Entity.release","title":"<code>release(resource, amount)</code>","text":"<p>Release a amount from the resource.</p> Source code in <code>Akatosh\\entity.py</code> <pre><code>def release(self, resource: Resource, amount: float) -&gt; bool:\n    \"\"\"Release a amount from the resource.\"\"\"\n    if resource.collect(self, amount):\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"api/event/","title":"Event","text":"Source code in <code>Akatosh\\event.py</code> <pre><code>class Event:\n\n    def __init__(\n        self,\n        at: float | Event,\n        till: float | Event,\n        action: Callable,\n        step: float = Mundus.time_step,\n        label: Optional[str] = None,\n        once: bool = False,\n        priority: int = 0,\n    ) -&gt; None:\n        \"\"\"Create an event which happens at a certain time and ends at a certain time.\n\n        Args:\n            at (float | Event): when the event should start.\n            till (float | Event): when the event should end.\n            action (Callable): what happens during the event.\n            label (Optional[str], optional): Short description for the event. Defaults to None.\n            once (bool, optional): whether this event should only happen once, regardless of at or till. Defaults to False.\n            priority (int, optional): the priority of the event, event with lower value will happen before the events with a higher priority value. Defaults to 0.\n\n        Raises:\n            ValueError: _description_\n        \"\"\"\n        self._at = at\n        self._till = till\n        self._action = action\n        self._started = False\n        self._acted = False\n        self._ended = False\n        self._paused = False\n        self._label = label\n        self._once = once\n        self._priority = priority\n        self._step = step\n        self._next = 0\n        Mundus.pending_events.append(self)\n        if self.priority &gt; Mundus.max_event_priority:\n            Mundus._max_event_priority = self.priority\n\n    async def __call__(self) -&gt; Any:\n        \"\"\"Make the event callable, so it can be awaited like a coroutine.\"\"\"\n        while True:\n\n            if self.ended == True:\n                return\n\n            while True:\n                if self.priority == Mundus.current_event_priority:\n                    break\n                else:\n                    await asyncio.sleep(0)\n\n            if self.started == False:\n                if isinstance(self.at, Event):\n                    if self.at.ended == True:\n                        self._started = True\n                        self._next = Mundus.time\n                        logger.debug(f\"Event {self} started at {Mundus.time}.\")\n                else:\n                    if self.at &lt;= Mundus.time:\n                        self._started = True\n                        self._next = Mundus.time\n                        logger.debug(f\"Event {self} started at {Mundus.time}.\")\n\n            if (\n                self.started == True\n                and self.ended == False\n                and self.paused == False\n                and self.next &lt;= Mundus.time\n            ):\n                if asyncio.iscoroutinefunction(self._action):\n                    await self._action()\n                else:\n                    self._action()\n                self._acted = True\n                if Mundus.realtime:\n                    if self.step != Mundus.time_step:\n                        self._next = round(\n                            Mundus.time + self.step,\n                            Mundus.time_resolution,\n                        )\n                    else:\n                        self._next = (\n                            Mundus.time\n                        )\n                else:\n                    self._next += max(Mundus.time_step, self.step)\n                    self._next = round(self._next, Mundus.time_resolution)\n                logger.debug(f\"Event {self} acted at {Mundus.time}.\")\n                if self._once == True:\n                    self._ended = True\n                    logger.debug(f\"Event {self} ended at {Mundus.time}.\")\n                    return\n\n            if self.ended == False:\n                if isinstance(self.till, Event):\n                    if self.till.ended == True:\n                        self._ended = True\n                        logger.debug(f\"Event {self} ended at {Mundus.time}.\")\n                        return\n                else:\n                    if self.till &lt;= Mundus.time:\n                        self._ended = True\n                        logger.debug(f\"Event {self} ended at {Mundus.time}.\")\n                        return\n            await asyncio.sleep(0)\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return the label of the event if it has one, otherwise return the id of the event.\"\"\"\n        if self.label is None:\n            return f\"Event {id(self)}\"\n        return self.label\n\n    def cancel(self):\n        \"\"\"Cancel the event.\"\"\"\n        self._ended = True\n        logger.debug(f\"Event {self} cancelled.\")\n\n    def pause(self):\n        \"\"\"Pause the event.\"\"\"\n        self._paused = True\n        logger.debug(f\"Event {self} paused.\")\n\n    def resume(self):\n        \"\"\"Resume the event.\"\"\"\n        self._paused = False\n        logger.debug(f\"Event {self} resumed.\")\n\n    @property\n    def at(self):\n        \"\"\"Return the time when the event should start.\"\"\"\n        return self._at\n\n    @property\n    def till(self):\n        \"\"\"Return the time when the event should end.\"\"\"\n        return self._till\n\n    @property\n    def started(self):\n        \"\"\"Return whether the event has started or not.\"\"\"\n        return self._started\n\n    @property\n    def ended(self):\n        \"\"\"Return whether the event has ended or not.\"\"\"\n        return self._ended\n\n    @property\n    def paused(self):\n        \"\"\"Return whether the event is paused or not.\"\"\"\n        return self._paused\n\n    @property\n    def label(self):\n        \"\"\"Return the label of the event.\"\"\"\n        return self._label\n\n    @property\n    def once(self):\n        \"\"\"Return whether the event should only happen once or not.\"\"\"\n        return self._once\n\n    @property\n    def priority(self):\n        \"\"\"Return the priority of the event.\"\"\"\n        return self._priority\n\n    @property\n    def next(self):\n        \"\"\"Return the next time the event acts.\"\"\"\n        return self._next\n\n    @property\n    def step(self):\n        \"\"\"Return the time step of the event, which overwrites the simulation time step.\"\"\"\n        return self._step\n</code></pre>"},{"location":"api/event/#Akatosh.event.Event.at","title":"<code>at</code>  <code>property</code>","text":"<p>Return the time when the event should start.</p>"},{"location":"api/event/#Akatosh.event.Event.ended","title":"<code>ended</code>  <code>property</code>","text":"<p>Return whether the event has ended or not.</p>"},{"location":"api/event/#Akatosh.event.Event.label","title":"<code>label</code>  <code>property</code>","text":"<p>Return the label of the event.</p>"},{"location":"api/event/#Akatosh.event.Event.next","title":"<code>next</code>  <code>property</code>","text":"<p>Return the next time the event acts.</p>"},{"location":"api/event/#Akatosh.event.Event.once","title":"<code>once</code>  <code>property</code>","text":"<p>Return whether the event should only happen once or not.</p>"},{"location":"api/event/#Akatosh.event.Event.paused","title":"<code>paused</code>  <code>property</code>","text":"<p>Return whether the event is paused or not.</p>"},{"location":"api/event/#Akatosh.event.Event.priority","title":"<code>priority</code>  <code>property</code>","text":"<p>Return the priority of the event.</p>"},{"location":"api/event/#Akatosh.event.Event.started","title":"<code>started</code>  <code>property</code>","text":"<p>Return whether the event has started or not.</p>"},{"location":"api/event/#Akatosh.event.Event.step","title":"<code>step</code>  <code>property</code>","text":"<p>Return the time step of the event, which overwrites the simulation time step.</p>"},{"location":"api/event/#Akatosh.event.Event.till","title":"<code>till</code>  <code>property</code>","text":"<p>Return the time when the event should end.</p>"},{"location":"api/event/#Akatosh.event.Event.__call__","title":"<code>__call__()</code>  <code>async</code>","text":"<p>Make the event callable, so it can be awaited like a coroutine.</p> Source code in <code>Akatosh\\event.py</code> <pre><code>async def __call__(self) -&gt; Any:\n    \"\"\"Make the event callable, so it can be awaited like a coroutine.\"\"\"\n    while True:\n\n        if self.ended == True:\n            return\n\n        while True:\n            if self.priority == Mundus.current_event_priority:\n                break\n            else:\n                await asyncio.sleep(0)\n\n        if self.started == False:\n            if isinstance(self.at, Event):\n                if self.at.ended == True:\n                    self._started = True\n                    self._next = Mundus.time\n                    logger.debug(f\"Event {self} started at {Mundus.time}.\")\n            else:\n                if self.at &lt;= Mundus.time:\n                    self._started = True\n                    self._next = Mundus.time\n                    logger.debug(f\"Event {self} started at {Mundus.time}.\")\n\n        if (\n            self.started == True\n            and self.ended == False\n            and self.paused == False\n            and self.next &lt;= Mundus.time\n        ):\n            if asyncio.iscoroutinefunction(self._action):\n                await self._action()\n            else:\n                self._action()\n            self._acted = True\n            if Mundus.realtime:\n                if self.step != Mundus.time_step:\n                    self._next = round(\n                        Mundus.time + self.step,\n                        Mundus.time_resolution,\n                    )\n                else:\n                    self._next = (\n                        Mundus.time\n                    )\n            else:\n                self._next += max(Mundus.time_step, self.step)\n                self._next = round(self._next, Mundus.time_resolution)\n            logger.debug(f\"Event {self} acted at {Mundus.time}.\")\n            if self._once == True:\n                self._ended = True\n                logger.debug(f\"Event {self} ended at {Mundus.time}.\")\n                return\n\n        if self.ended == False:\n            if isinstance(self.till, Event):\n                if self.till.ended == True:\n                    self._ended = True\n                    logger.debug(f\"Event {self} ended at {Mundus.time}.\")\n                    return\n            else:\n                if self.till &lt;= Mundus.time:\n                    self._ended = True\n                    logger.debug(f\"Event {self} ended at {Mundus.time}.\")\n                    return\n        await asyncio.sleep(0)\n</code></pre>"},{"location":"api/event/#Akatosh.event.Event.__init__","title":"<code>__init__(at, till, action, step=Mundus.time_step, label=None, once=False, priority=0)</code>","text":"<p>Create an event which happens at a certain time and ends at a certain time.</p> <p>Parameters:</p> Name Type Description Default <code>at</code> <code>float | Event</code> <p>when the event should start.</p> required <code>till</code> <code>float | Event</code> <p>when the event should end.</p> required <code>action</code> <code>Callable</code> <p>what happens during the event.</p> required <code>label</code> <code>Optional[str]</code> <p>Short description for the event. Defaults to None.</p> <code>None</code> <code>once</code> <code>bool</code> <p>whether this event should only happen once, regardless of at or till. Defaults to False.</p> <code>False</code> <code>priority</code> <code>int</code> <p>the priority of the event, event with lower value will happen before the events with a higher priority value. Defaults to 0.</p> <code>0</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>description</p> Source code in <code>Akatosh\\event.py</code> <pre><code>def __init__(\n    self,\n    at: float | Event,\n    till: float | Event,\n    action: Callable,\n    step: float = Mundus.time_step,\n    label: Optional[str] = None,\n    once: bool = False,\n    priority: int = 0,\n) -&gt; None:\n    \"\"\"Create an event which happens at a certain time and ends at a certain time.\n\n    Args:\n        at (float | Event): when the event should start.\n        till (float | Event): when the event should end.\n        action (Callable): what happens during the event.\n        label (Optional[str], optional): Short description for the event. Defaults to None.\n        once (bool, optional): whether this event should only happen once, regardless of at or till. Defaults to False.\n        priority (int, optional): the priority of the event, event with lower value will happen before the events with a higher priority value. Defaults to 0.\n\n    Raises:\n        ValueError: _description_\n    \"\"\"\n    self._at = at\n    self._till = till\n    self._action = action\n    self._started = False\n    self._acted = False\n    self._ended = False\n    self._paused = False\n    self._label = label\n    self._once = once\n    self._priority = priority\n    self._step = step\n    self._next = 0\n    Mundus.pending_events.append(self)\n    if self.priority &gt; Mundus.max_event_priority:\n        Mundus._max_event_priority = self.priority\n</code></pre>"},{"location":"api/event/#Akatosh.event.Event.__str__","title":"<code>__str__()</code>","text":"<p>Return the label of the event if it has one, otherwise return the id of the event.</p> Source code in <code>Akatosh\\event.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return the label of the event if it has one, otherwise return the id of the event.\"\"\"\n    if self.label is None:\n        return f\"Event {id(self)}\"\n    return self.label\n</code></pre>"},{"location":"api/event/#Akatosh.event.Event.cancel","title":"<code>cancel()</code>","text":"<p>Cancel the event.</p> Source code in <code>Akatosh\\event.py</code> <pre><code>def cancel(self):\n    \"\"\"Cancel the event.\"\"\"\n    self._ended = True\n    logger.debug(f\"Event {self} cancelled.\")\n</code></pre>"},{"location":"api/event/#Akatosh.event.Event.pause","title":"<code>pause()</code>","text":"<p>Pause the event.</p> Source code in <code>Akatosh\\event.py</code> <pre><code>def pause(self):\n    \"\"\"Pause the event.\"\"\"\n    self._paused = True\n    logger.debug(f\"Event {self} paused.\")\n</code></pre>"},{"location":"api/event/#Akatosh.event.Event.resume","title":"<code>resume()</code>","text":"<p>Resume the event.</p> Source code in <code>Akatosh\\event.py</code> <pre><code>def resume(self):\n    \"\"\"Resume the event.\"\"\"\n    self._paused = False\n    logger.debug(f\"Event {self} resumed.\")\n</code></pre>"},{"location":"api/resource/","title":"Resource","text":"Source code in <code>Akatosh\\resource.py</code> <pre><code>class Resource:\n\n    def __init__(self, capacity: float, usage: float = 0.0) -&gt; None:\n        \"\"\"Create a resource with a given capacity and initial usage.\n\n        Args:\n            capacity (float): the maximum amount of resource that can be stored.\n            usage (float, optional): the initial usage of the resource. Defaults to 0.0.\n        \"\"\"\n        self._capacity = capacity\n        if usage &gt; capacity:\n            logger.warn(f\"Initial usage of the resource is greater than the capacity. Setting usage to capacity.\")\n            self._usage = capacity\n        else:\n            self._usage = usage\n        self._users: List[Tuple[Entity, float]] = list()\n\n    def distribute(self, user: Entity, amount: float = inf) -&gt; bool:\n        \"\"\"Distribute the given amount of resource to the user.\"\"\"\n        if amount == inf:\n            existing_users = [user[0] for user in self.users]\n            if user in existing_users:\n                index = existing_users.index(user)\n                self._users[index] = (user, self.users[index][1] + self.level)\n                self._usage += self.level\n            else:\n                self._usage += self.level\n                self.users.append((user, self.level))\n                user.occupied_resources.append(self)\n            logger.debug(f\"{self} distributed all available resource to {user}.\")\n            return True\n\n        if self.level &gt; amount:\n            self._usage += amount\n            existing_users = [user[0] for user in self.users]\n            if user in existing_users:\n                index = existing_users.index(user)\n                self._users[index] = (user, self.users[index][1] + amount)\n            else:\n                self.users.append((user, amount))\n                user.occupied_resources.append(self)\n            logger.debug(f\"{self} distributed {amount} to {user}.\")\n            return True\n        else:\n            logger.warn(f\"{self} cannot distribute {amount} to {user}. Not enough resource.\")\n            existing_users = [user[0] for user in self.users]\n            if user in existing_users:\n                index = existing_users.index(user)\n                self._users[index] = (user, self.users[index][1] + self.level)\n                self._usage += self.level\n            else:\n                self._usage += self.level\n                self.users.append((user, self.level))\n                user.occupied_resources.append(self)\n            logger.debug(f\"{self} distributed all available resource to {user}.\")\n            return False\n\n    def collect(self, user: Entity, amount: float = inf) -&gt; bool:\n        \"\"\"Collect the resource from the user. If the amount is infinite, the user will be removed from the users list and all amount will be collected.\"\"\"\n        if amount == inf:\n            existing_users = [user[0] for user in self.users]\n            if user in existing_users:\n                index = existing_users.index(user)\n                self._usage -= self.users[index][1]\n                self.users.pop(index)\n                user.occupied_resources.remove(self)\n                logger.debug(f\"{self} collected all occupied resource from {user}.\")\n                return True\n            else:\n                logger.warn(f\"{self} cannot collect resource from non-user {user}.\")\n                return False\n\n        existing_users = [user[0] for user in self.users]\n        if user in existing_users:\n            index = existing_users.index(user)\n            if self.users[index][1] &gt; amount:\n                self._usage -= amount\n                self._users[index] = (user, self.users[index][1] - amount)\n                return True\n            else:\n                logger.warn(f\"{self} cannot collect {amount} from {user}. Not enough resource occupied by the user.\")\n                self._usage -= self.users[index][1]\n                self.users.pop(index)\n                user.occupied_resources.remove(self)\n                logger.debug(f\"{self} collected all occupied resource from {user}.\")\n                return False\n        else:\n            logger.warn(f\"{self} cannot collect resource from non-user {user}.\")\n            return False\n\n    def reset(self) -&gt; None:\n        \"\"\"Reset the resource level and users.\"\"\"\n        self._usage = 0.0\n        for user in self.users:\n            user[0].occupied_resources.remove(self)\n        self._users.clear()\n\n    @property\n    def capacity(self) -&gt; float:\n        \"\"\"The maximum amount of resource that can be stored.\"\"\"\n        return self._capacity\n\n    @property\n    def usage(self) -&gt; float:\n        \"\"\"The current usage of the resource.\"\"\"\n        return self._usage\n\n    @property\n    def level(self) -&gt; float:\n        \"\"\"The current level of the resource.\"\"\"\n        return self.capacity - self.usage\n\n    @property\n    def users(self) -&gt; List[Tuple[Entity, float]]:\n        \"\"\"The users of the resource. Each user is a tuple of the entity and the amount of resource used by the entity.\"\"\"\n        return self._users\n</code></pre>"},{"location":"api/resource/#Akatosh.resource.Resource.capacity","title":"<code>capacity: float</code>  <code>property</code>","text":"<p>The maximum amount of resource that can be stored.</p>"},{"location":"api/resource/#Akatosh.resource.Resource.level","title":"<code>level: float</code>  <code>property</code>","text":"<p>The current level of the resource.</p>"},{"location":"api/resource/#Akatosh.resource.Resource.usage","title":"<code>usage: float</code>  <code>property</code>","text":"<p>The current usage of the resource.</p>"},{"location":"api/resource/#Akatosh.resource.Resource.users","title":"<code>users: List[Tuple[Entity, float]]</code>  <code>property</code>","text":"<p>The users of the resource. Each user is a tuple of the entity and the amount of resource used by the entity.</p>"},{"location":"api/resource/#Akatosh.resource.Resource.__init__","title":"<code>__init__(capacity, usage=0.0)</code>","text":"<p>Create a resource with a given capacity and initial usage.</p> <p>Parameters:</p> Name Type Description Default <code>capacity</code> <code>float</code> <p>the maximum amount of resource that can be stored.</p> required <code>usage</code> <code>float</code> <p>the initial usage of the resource. Defaults to 0.0.</p> <code>0.0</code> Source code in <code>Akatosh\\resource.py</code> <pre><code>def __init__(self, capacity: float, usage: float = 0.0) -&gt; None:\n    \"\"\"Create a resource with a given capacity and initial usage.\n\n    Args:\n        capacity (float): the maximum amount of resource that can be stored.\n        usage (float, optional): the initial usage of the resource. Defaults to 0.0.\n    \"\"\"\n    self._capacity = capacity\n    if usage &gt; capacity:\n        logger.warn(f\"Initial usage of the resource is greater than the capacity. Setting usage to capacity.\")\n        self._usage = capacity\n    else:\n        self._usage = usage\n    self._users: List[Tuple[Entity, float]] = list()\n</code></pre>"},{"location":"api/resource/#Akatosh.resource.Resource.collect","title":"<code>collect(user, amount=inf)</code>","text":"<p>Collect the resource from the user. If the amount is infinite, the user will be removed from the users list and all amount will be collected.</p> Source code in <code>Akatosh\\resource.py</code> <pre><code>def collect(self, user: Entity, amount: float = inf) -&gt; bool:\n    \"\"\"Collect the resource from the user. If the amount is infinite, the user will be removed from the users list and all amount will be collected.\"\"\"\n    if amount == inf:\n        existing_users = [user[0] for user in self.users]\n        if user in existing_users:\n            index = existing_users.index(user)\n            self._usage -= self.users[index][1]\n            self.users.pop(index)\n            user.occupied_resources.remove(self)\n            logger.debug(f\"{self} collected all occupied resource from {user}.\")\n            return True\n        else:\n            logger.warn(f\"{self} cannot collect resource from non-user {user}.\")\n            return False\n\n    existing_users = [user[0] for user in self.users]\n    if user in existing_users:\n        index = existing_users.index(user)\n        if self.users[index][1] &gt; amount:\n            self._usage -= amount\n            self._users[index] = (user, self.users[index][1] - amount)\n            return True\n        else:\n            logger.warn(f\"{self} cannot collect {amount} from {user}. Not enough resource occupied by the user.\")\n            self._usage -= self.users[index][1]\n            self.users.pop(index)\n            user.occupied_resources.remove(self)\n            logger.debug(f\"{self} collected all occupied resource from {user}.\")\n            return False\n    else:\n        logger.warn(f\"{self} cannot collect resource from non-user {user}.\")\n        return False\n</code></pre>"},{"location":"api/resource/#Akatosh.resource.Resource.distribute","title":"<code>distribute(user, amount=inf)</code>","text":"<p>Distribute the given amount of resource to the user.</p> Source code in <code>Akatosh\\resource.py</code> <pre><code>def distribute(self, user: Entity, amount: float = inf) -&gt; bool:\n    \"\"\"Distribute the given amount of resource to the user.\"\"\"\n    if amount == inf:\n        existing_users = [user[0] for user in self.users]\n        if user in existing_users:\n            index = existing_users.index(user)\n            self._users[index] = (user, self.users[index][1] + self.level)\n            self._usage += self.level\n        else:\n            self._usage += self.level\n            self.users.append((user, self.level))\n            user.occupied_resources.append(self)\n        logger.debug(f\"{self} distributed all available resource to {user}.\")\n        return True\n\n    if self.level &gt; amount:\n        self._usage += amount\n        existing_users = [user[0] for user in self.users]\n        if user in existing_users:\n            index = existing_users.index(user)\n            self._users[index] = (user, self.users[index][1] + amount)\n        else:\n            self.users.append((user, amount))\n            user.occupied_resources.append(self)\n        logger.debug(f\"{self} distributed {amount} to {user}.\")\n        return True\n    else:\n        logger.warn(f\"{self} cannot distribute {amount} to {user}. Not enough resource.\")\n        existing_users = [user[0] for user in self.users]\n        if user in existing_users:\n            index = existing_users.index(user)\n            self._users[index] = (user, self.users[index][1] + self.level)\n            self._usage += self.level\n        else:\n            self._usage += self.level\n            self.users.append((user, self.level))\n            user.occupied_resources.append(self)\n        logger.debug(f\"{self} distributed all available resource to {user}.\")\n        return False\n</code></pre>"},{"location":"api/resource/#Akatosh.resource.Resource.reset","title":"<code>reset()</code>","text":"<p>Reset the resource level and users.</p> Source code in <code>Akatosh\\resource.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"Reset the resource level and users.\"\"\"\n    self._usage = 0.0\n    for user in self.users:\n        user[0].occupied_resources.remove(self)\n    self._users.clear()\n</code></pre>"},{"location":"api/universe/","title":"Universe","text":"Source code in <code>Akatosh\\universe.py</code> <pre><code>class Universe:\n    _instance = None\n\n    def __new__(cls):\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n        return cls._instance\n\n    def __init__(self) -&gt; None:\n        \"\"\"The simulation universe.\"\"\"\n        self._time_resolution = 3\n        self._time_scale = 1\n        self._time_step = round(1 / pow(10, self.time_resolution), self.time_resolution)\n        self._time = 0\n        self._simulation_start_time = 0\n        self._simulation_end_time = 0\n        self._realtime = False\n        self._current_event_priority = 0\n        self._max_event_priority = 0\n        self._pending_events: List[Event] = list()\n        self._paused = False\n\n    def simulate(self, till: float):\n        \"\"\"Simulate the universe until the given time.\"\"\"\n\n        # Define the flow of time\n        async def time_flow():\n            \"\"\"Flow of time.\"\"\"\n            self._simulation_start_time = time.perf_counter()\n            while self.time &lt; till:\n                if self.paused:\n                    await asyncio.sleep(0)\n                    continue\n                logger.debug(f\"Simulation time:\\t{self.time}\")\n                for event in self.pending_events:\n                    asyncio.create_task(event())\n                self.pending_events.clear()\n                if self.realtime:\n                    iteration_start_time = (\n                        time.perf_counter() - self.simulation_start_time\n                    )\n                    logger.debug(\n                        f\"Iteration started at Real Time: {iteration_start_time:0.6f}\"\n                    )\n                    # iterate through all event priorities\n                    self._current_event_priority = 0\n                    while self.current_event_priority &lt;= self._max_event_priority:\n                        logger.debug(\n                            f\"Current Event Priority: {self.current_event_priority}\"\n                        )\n                        await asyncio.sleep(0)\n                        self._current_event_priority += 1\n                    # finish the iteration\n                    iteration_end_time = (\n                        time.perf_counter() - self.simulation_start_time\n                    )\n                    # update the time\n                    self._time += (iteration_end_time - iteration_start_time) * self.time_scale\n                    logger.debug(\n                        f\"Iteration finished at Real Time: {iteration_end_time:0.6f}\"\n                    )\n                    logger.debug(\n                        f\"FPS: {1/(iteration_end_time - iteration_start_time):0.6f}\"\n                    )\n                    await asyncio.sleep(0)\n\n                else:\n                    # iterate through all event priorities\n                    self._current_event_priority = 0\n                    while self.current_event_priority &lt;= self._max_event_priority:\n                        logger.debug(\n                            f\"Current Event Priority: {self.current_event_priority}\"\n                        )\n                        await asyncio.sleep(0)\n                        self._current_event_priority += 1\n                    # wait for the time step\n                    self._time += self.time_step\n                    self._time = round(self.time, self.time_resolution)\n                    await asyncio.sleep(0)\n\n            self._simulation_end_time = time.perf_counter()\n            if self.realtime:\n                logger.info(\n                    f\"Simulation completed in {round(self.simulation_end_time - self.simulation_start_time, 6)} seconds, exceeding real time by {round(((self.simulation_end_time - self.simulation_start_time - till)/till)*100,2)}%.\"\n                )\n\n        return time_flow()\n\n    def enable_realtime(self):\n        \"\"\"Enable the real time simulation.\"\"\"\n        self._realtime = True\n\n    def disable_realtime(self):\n        \"\"\"Disable the real time simulation.\"\"\"\n        self._realtime = False\n\n    def set_timescale(self, scale: float):\n        \"\"\"Set the time scale of the simulation. Default is 1. Only works in real time mode.\"\"\"\n        if not self.realtime:\n            logger.warning(\"Time scale only works in real time mode.\")\n            return\n        self.pause()\n        self._time_scale = scale\n        self.resume()\n\n    def pause(self):\n        \"\"\"Pause the simulation.\"\"\"\n        if self.paused:\n            logger.warning(\"Simulation is already paused.\")\n            return\n        self._paused = True\n        logger.debug(f\"Simulation paused at {self.time}.\")\n\n    def resume(self):\n        \"\"\"Resume the simulation.\"\"\"\n        if not self.paused:\n            logger.warning(\"Simulation is already running.\")\n            return\n        self._paused = False\n        logger.debug(f\"Simulation resumed at {self.time}.\")\n\n    def set_logging_level(self, level: int = logging.DEBUG):\n        \"\"\"Set the logging level. Default is DEBUG.\"\"\"\n        logger.setLevel(level)\n\n    @property\n    def time(self):\n        \"\"\"Return the current time.\"\"\"\n        return self._time\n\n    @property\n    def time_resolution(self):\n        \"\"\"Return the time resolution. 1 for 0.1s, 2 for 0.01s, 3 for 0.001s, and so on. Default is 3.\"\"\"\n        if self._time_resolution &lt; 0:\n            raise ValueError(\"Time resolution cannot be less than 0.\")\n        return self._time_resolution\n\n    @time_resolution.setter\n    def time_resolution(self, value: int):\n        \"\"\"Set the time resolution. 1 for 0.1s, 2 for 0.01s, 3 for 0.001s, and so on. Default is 3.\"\"\"\n        if value &lt; 0:\n            raise ValueError(\"Time resolution cannot be less than 0.\")\n        self._time_resolution = value\n        self._time_step = round(1 / pow(10, self.time_resolution), self.time_resolution)\n\n    @property\n    def time_step(self):\n        \"\"\"The time step of the simulation. Default is 0.001s.\"\"\"\n        return self._time_step\n\n    @property\n    def realtime(self):\n        \"\"\"Return True if the simulation is in real time mode, otherwise False. Default is False.\"\"\"\n        return self._realtime\n\n    @property\n    def pending_events(self):\n        \"\"\"The events that are pending to be executed. Please note that this is not the queue for future events. This is used for start async tasks for the events.\"\"\"\n        return self._pending_events\n\n    @property\n    def current_event_priority(self):\n        \"\"\"The current event priority.\"\"\"\n        return self._current_event_priority\n\n    @property\n    def max_event_priority(self):\n        \"\"\"The maximum event priority.\"\"\"\n        return self._max_event_priority\n\n    @property\n    def simulation_start_time(self):\n        \"\"\"The time when the simulation started.\"\"\"\n        return self._simulation_start_time\n\n    @property\n    def simulation_end_time(self):\n        \"\"\"The time when the simulation ended.\"\"\"\n        return self._simulation_end_time\n\n    @property\n    def time_scale(self):\n        \"\"\"The time scale of the simulation. Default is 1. Only works in real time mode.\"\"\"\n        return self._time_scale\n\n    @property\n    def paused(self):\n        \"\"\"Return True if the simulation is paused, otherwise False.\"\"\"\n        return self._paused\n</code></pre>"},{"location":"api/universe/#Akatosh.universe.Universe.current_event_priority","title":"<code>current_event_priority</code>  <code>property</code>","text":"<p>The current event priority.</p>"},{"location":"api/universe/#Akatosh.universe.Universe.max_event_priority","title":"<code>max_event_priority</code>  <code>property</code>","text":"<p>The maximum event priority.</p>"},{"location":"api/universe/#Akatosh.universe.Universe.paused","title":"<code>paused</code>  <code>property</code>","text":"<p>Return True if the simulation is paused, otherwise False.</p>"},{"location":"api/universe/#Akatosh.universe.Universe.pending_events","title":"<code>pending_events</code>  <code>property</code>","text":"<p>The events that are pending to be executed. Please note that this is not the queue for future events. This is used for start async tasks for the events.</p>"},{"location":"api/universe/#Akatosh.universe.Universe.realtime","title":"<code>realtime</code>  <code>property</code>","text":"<p>Return True if the simulation is in real time mode, otherwise False. Default is False.</p>"},{"location":"api/universe/#Akatosh.universe.Universe.simulation_end_time","title":"<code>simulation_end_time</code>  <code>property</code>","text":"<p>The time when the simulation ended.</p>"},{"location":"api/universe/#Akatosh.universe.Universe.simulation_start_time","title":"<code>simulation_start_time</code>  <code>property</code>","text":"<p>The time when the simulation started.</p>"},{"location":"api/universe/#Akatosh.universe.Universe.time","title":"<code>time</code>  <code>property</code>","text":"<p>Return the current time.</p>"},{"location":"api/universe/#Akatosh.universe.Universe.time_resolution","title":"<code>time_resolution</code>  <code>property</code> <code>writable</code>","text":"<p>Return the time resolution. 1 for 0.1s, 2 for 0.01s, 3 for 0.001s, and so on. Default is 3.</p>"},{"location":"api/universe/#Akatosh.universe.Universe.time_scale","title":"<code>time_scale</code>  <code>property</code>","text":"<p>The time scale of the simulation. Default is 1. Only works in real time mode.</p>"},{"location":"api/universe/#Akatosh.universe.Universe.time_step","title":"<code>time_step</code>  <code>property</code>","text":"<p>The time step of the simulation. Default is 0.001s.</p>"},{"location":"api/universe/#Akatosh.universe.Universe.__init__","title":"<code>__init__()</code>","text":"<p>The simulation universe.</p> Source code in <code>Akatosh\\universe.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"The simulation universe.\"\"\"\n    self._time_resolution = 3\n    self._time_scale = 1\n    self._time_step = round(1 / pow(10, self.time_resolution), self.time_resolution)\n    self._time = 0\n    self._simulation_start_time = 0\n    self._simulation_end_time = 0\n    self._realtime = False\n    self._current_event_priority = 0\n    self._max_event_priority = 0\n    self._pending_events: List[Event] = list()\n    self._paused = False\n</code></pre>"},{"location":"api/universe/#Akatosh.universe.Universe.disable_realtime","title":"<code>disable_realtime()</code>","text":"<p>Disable the real time simulation.</p> Source code in <code>Akatosh\\universe.py</code> <pre><code>def disable_realtime(self):\n    \"\"\"Disable the real time simulation.\"\"\"\n    self._realtime = False\n</code></pre>"},{"location":"api/universe/#Akatosh.universe.Universe.enable_realtime","title":"<code>enable_realtime()</code>","text":"<p>Enable the real time simulation.</p> Source code in <code>Akatosh\\universe.py</code> <pre><code>def enable_realtime(self):\n    \"\"\"Enable the real time simulation.\"\"\"\n    self._realtime = True\n</code></pre>"},{"location":"api/universe/#Akatosh.universe.Universe.pause","title":"<code>pause()</code>","text":"<p>Pause the simulation.</p> Source code in <code>Akatosh\\universe.py</code> <pre><code>def pause(self):\n    \"\"\"Pause the simulation.\"\"\"\n    if self.paused:\n        logger.warning(\"Simulation is already paused.\")\n        return\n    self._paused = True\n    logger.debug(f\"Simulation paused at {self.time}.\")\n</code></pre>"},{"location":"api/universe/#Akatosh.universe.Universe.resume","title":"<code>resume()</code>","text":"<p>Resume the simulation.</p> Source code in <code>Akatosh\\universe.py</code> <pre><code>def resume(self):\n    \"\"\"Resume the simulation.\"\"\"\n    if not self.paused:\n        logger.warning(\"Simulation is already running.\")\n        return\n    self._paused = False\n    logger.debug(f\"Simulation resumed at {self.time}.\")\n</code></pre>"},{"location":"api/universe/#Akatosh.universe.Universe.set_logging_level","title":"<code>set_logging_level(level=logging.DEBUG)</code>","text":"<p>Set the logging level. Default is DEBUG.</p> Source code in <code>Akatosh\\universe.py</code> <pre><code>def set_logging_level(self, level: int = logging.DEBUG):\n    \"\"\"Set the logging level. Default is DEBUG.\"\"\"\n    logger.setLevel(level)\n</code></pre>"},{"location":"api/universe/#Akatosh.universe.Universe.set_timescale","title":"<code>set_timescale(scale)</code>","text":"<p>Set the time scale of the simulation. Default is 1. Only works in real time mode.</p> Source code in <code>Akatosh\\universe.py</code> <pre><code>def set_timescale(self, scale: float):\n    \"\"\"Set the time scale of the simulation. Default is 1. Only works in real time mode.\"\"\"\n    if not self.realtime:\n        logger.warning(\"Time scale only works in real time mode.\")\n        return\n    self.pause()\n    self._time_scale = scale\n    self.resume()\n</code></pre>"},{"location":"api/universe/#Akatosh.universe.Universe.simulate","title":"<code>simulate(till)</code>","text":"<p>Simulate the universe until the given time.</p> Source code in <code>Akatosh\\universe.py</code> <pre><code>def simulate(self, till: float):\n    \"\"\"Simulate the universe until the given time.\"\"\"\n\n    # Define the flow of time\n    async def time_flow():\n        \"\"\"Flow of time.\"\"\"\n        self._simulation_start_time = time.perf_counter()\n        while self.time &lt; till:\n            if self.paused:\n                await asyncio.sleep(0)\n                continue\n            logger.debug(f\"Simulation time:\\t{self.time}\")\n            for event in self.pending_events:\n                asyncio.create_task(event())\n            self.pending_events.clear()\n            if self.realtime:\n                iteration_start_time = (\n                    time.perf_counter() - self.simulation_start_time\n                )\n                logger.debug(\n                    f\"Iteration started at Real Time: {iteration_start_time:0.6f}\"\n                )\n                # iterate through all event priorities\n                self._current_event_priority = 0\n                while self.current_event_priority &lt;= self._max_event_priority:\n                    logger.debug(\n                        f\"Current Event Priority: {self.current_event_priority}\"\n                    )\n                    await asyncio.sleep(0)\n                    self._current_event_priority += 1\n                # finish the iteration\n                iteration_end_time = (\n                    time.perf_counter() - self.simulation_start_time\n                )\n                # update the time\n                self._time += (iteration_end_time - iteration_start_time) * self.time_scale\n                logger.debug(\n                    f\"Iteration finished at Real Time: {iteration_end_time:0.6f}\"\n                )\n                logger.debug(\n                    f\"FPS: {1/(iteration_end_time - iteration_start_time):0.6f}\"\n                )\n                await asyncio.sleep(0)\n\n            else:\n                # iterate through all event priorities\n                self._current_event_priority = 0\n                while self.current_event_priority &lt;= self._max_event_priority:\n                    logger.debug(\n                        f\"Current Event Priority: {self.current_event_priority}\"\n                    )\n                    await asyncio.sleep(0)\n                    self._current_event_priority += 1\n                # wait for the time step\n                self._time += self.time_step\n                self._time = round(self.time, self.time_resolution)\n                await asyncio.sleep(0)\n\n        self._simulation_end_time = time.perf_counter()\n        if self.realtime:\n            logger.info(\n                f\"Simulation completed in {round(self.simulation_end_time - self.simulation_start_time, 6)} seconds, exceeding real time by {round(((self.simulation_end_time - self.simulation_start_time - till)/till)*100,2)}%.\"\n            )\n\n    return time_flow()\n</code></pre>"},{"location":"guides/entity/","title":"Entity","text":"<p>In Akatosh, an Entity is an object that can engage events during its life-cycle like a NPC. The NPC like in games, can \"do different things\" and \"these things\" stop happening when the NPC is died.</p>"},{"location":"guides/entity/#create-an-entity","title":"Create an Entity","text":"<p>Entity can be created similar to an event:</p> <pre><code>import asyncio\nfrom Akatosh.entity import Entity\nfrom Akatosh.universe import universe\n\nentity = Entity(1,3,\"Entity\") \nasyncio.run(universe.simulate(4))\n</code></pre> <p>However, upon creation of a entity, two instant events are created: creation &amp; termination, which determine the life cycle of the entity. These two events can be accessed as:</p> <pre><code>entity.creation\nentity.termination\n</code></pre>"},{"location":"guides/entity/#create-an-entity-after-an-event","title":"Create an Entity after an event","text":"<p>Similar to event, you can define the creation time of an entity based on an event:</p> <pre><code>import asyncio\nfrom Akatosh.entity import Entity\nfrom Akatosh.universe import universe\n\nentity = Entity(1,3,\"Entity\") \nentity2 = Entity(entity.termination, 4, \"Second Entity\") # entity 2 will be created after the first entity is terminated.\nasyncio.run(universe.simulate(4))\n</code></pre>"},{"location":"guides/entity/#entity-with-priority","title":"Entity with priority","text":"<p>Same as events, you can give priority to entity which are scheduled to be created at the same time:</p> <pre><code>import asyncio\nfrom Akatosh.entity import Entity\nfrom Akatosh.universe import universe\n\nentity1 = Entity(1,3,\"Entity 1\", 1)\nentity2 = Entity(1,4,\"Entity 2\", 2) # entity2 will be created after entity1 but still at 1s.\n\nuniverse.set_time_resolution(0)\nasyncio.run(universe.simulate(4))\n</code></pre>"},{"location":"guides/entity/#engage-a-event","title":"Engage a event","text":"<p>Akatosh gives a decorator to allow entity to engage an event. The engaged event will be assoicated with the entity. If a continous entity is engaged, it will be cancelled if the entity is terminated but the event is not ended. If a instant event is engaged but the entity terminated before it starts, the event will also be cancelled.</p> <pre><code>@entity.event(2,2,\"Hello World\")\ndef hello_world():\n    print(\"Hello World!\")\n</code></pre>"},{"location":"guides/event/","title":"Event","text":"<p>In Akatosh, \"Any thing that is going to happen\" is described as an event.</p>"},{"location":"guides/event/#instant-event","title":"Instant event","text":"<p>If a event has the at and till set to the same time, then the event is instant which means it only happens once at the given time.</p> <pre><code>import asyncio\nfrom Akatosh.event import event\nfrom Akatosh.universe import universe\n\n\n@event(1.5,1.5) # a simple instant event which \ndef hello_world():\n    print(f\"Hello World at {universe.time}!\")\n\nuniverse.set_time_resolution(1)\nasyncio.run(universe.simulate(2))\n</code></pre>"},{"location":"guides/event/#continous-event","title":"Continous event","text":"<p>The following codes shows a continous event between 1s and 1.5s. This event will act every time step during the simulation. If once set to true, then the event will only act once although it has been set to a period.</p> <pre><code>import asyncio\nfrom Akatosh.event import event\nfrom Akatosh.universe import universe\n\n\n@event(1,1.5)\ndef hello_world():\n    print(f\"Hello World at {universe.time}!\")\n\nuniverse.set_time_resolution(1)\nasyncio.run(universe.simulate(2))\n</code></pre>"},{"location":"guides/event/#cancel-a-event","title":"Cancel a event","text":"<p>The continous event can be canceled at any time. Cancelled event can not be resumed because the event will be considered as ended.</p> <pre><code>import asyncio\nfrom Akatosh.event import Event\nfrom Akatosh.universe import universe\n\nhello_world = Event(1, 1.5, lambda: print(\"Hello World!\"))\ncancel = Event(1.3,1.3, lambda: hello_world.cancel())\n\nuniverse.set_time_resolution(1)\nasyncio.run(universe.simulate(2))\n</code></pre>"},{"location":"guides/event/#pause-a-event","title":"Pause a event","text":"<p>The continous event can be paused which allows it to resumed later. But please note the priority. If the pause event has a higher priority value, then the targeted event will still act at that time. You can still resume a event that is already passed the end time but the event will not act.</p> <pre><code>import asyncio\nfrom Akatosh.event import Event\nfrom Akatosh.universe import universe\n\nhello_world = Event(1, 1.5, lambda: print(\"Hello World!\"), priority=1)\npause = Event(1.2,1.2, lambda: hello_world.pause()) # hello_world event will not act at 1.2 because the pause has priority 0.\nresume = Event(1.4,1.4, lambda: hello_world.resume(), 1) # hellow_world event will not act at 1.4 because the pause has priority 1.\n\nuniverse.set_time_resolution(1)\nasyncio.run(universe.simulate(2))\n</code></pre>"},{"location":"guides/event/#make-a-event-wait-for-another-event","title":"Make a event wait for another event","text":"<p>The following code print \"hello world\" at 0.5s by two events. The order of the word is ensured by let the world event wait for hello event.</p> <pre><code>import asyncio\nfrom Akatosh.event import Event\nfrom Akatosh.universe import universe\n\nhello = Event(0.5, 0.5, lambda: print(\"Hello\"))\nworld = Event(hello, 0.5, lambda: print(\"World\"))\n\nuniverse.set_time_resolution(1)\nasyncio.run(universe.simulate(1))\n</code></pre>"},{"location":"guides/event/#create-an-event-within-an-event","title":"Create an event within an event","text":"<p>The following codes demenstrate how to create a event within a event. Please note that the new event must be created after the current event.</p> <pre><code>import asyncio\nfrom Akatosh.event import event\nfrom Akatosh.universe import universe\n\n@event(0.5, 0.5)\ndef hello():\n    print(\"Hello\")\n\n    @event(0.6,0.6) # new event must be after the current event\n    def world():\n        print(\"World\")\n\nuniverse.set_time_resolution(1)\nasyncio.run(universe.simulate(1))\n</code></pre>"},{"location":"guides/event/#handle-events-at-the-same-time","title":"Handle events at the same time","text":"<p>The order for events which are scheduled at the same time to happen can be determined by the priority.</p> <pre><code>import asyncio\nfrom Akatosh.event import event\nfrom Akatosh.universe import universe\n\n\n@event(1,1, \"Event 2\", once=True, priority=2)\ndef event2():\n    print(\"World\")\n\n@event(1,1, \"Event 1\", once=True, priority=1)\ndef event1():\n    print(\"Hello\")\n\nuniverse.set_time_resolution(0)\nasyncio.run(universe.simulate(2))\n</code></pre>"},{"location":"guides/realtime/","title":"Real Time Simulation","text":"<p>This is a unique feature of Akatosh that it is capable of simulting event in real time. It is achieved by carefully using the combination of while loop and asyncio.sleep which gurantees the simulation time step is sync with real time. In each time step, the event will be executed based on their priorities. As long as the execution time of your scheduled event is not exceeding the time step resolution (defualt to 1ms), your events will be in sync with real time.</p> <pre><code>import asyncio\nfrom Akatosh.event import event\nfrom Akatosh.universe import Mundus\n\n\n@event(1, 1.5)\ndef hello_world():\n    print(f\"Hello World at {Mundus.time}!\")\n\nMundus.enable_realtime(2)\nasyncio.run(Mundus.simulate(2))\n</code></pre> <p>The above codes will print \"Hello World at {Mundus.time}\" every 10ms fromm 1s to 1.5s!</p>"},{"location":"guides/realtime/#time-scale","title":"Time Scale","text":"<p>You can also set time scale to make the real time simulation run faster than realtime. (Please note that relativity theory will not be considered if your time scale is huge...)</p> <pre><code>Mundus.set_timescale(5) # this will make simulation run 5x faster than real time!\n</code></pre> <p>You can change the time scale at any time while the simulation is runing, even with a event itself.</p>"},{"location":"guides/realtime/#pause-and-resume","title":"Pause and Resume","text":"<p>You can also pause and resume the simulation.</p> <pre><code>Mundus.pause() # this will pause the simulation.\nMundus.resume() # this will resume the simulation.\n</code></pre> <p>Technically, this should works for non-real time mode too.</p>"},{"location":"guides/resource/","title":"Resource","text":"<p><code>Resource</code> can be distributed to <code>Entity</code> or collect from them. It has a capacity for overall amount can be stored, a current level for the overall amount left and a usage for overall amount has been disyributed. <code>Resource</code> tracks the usage per <code>Entity</code>. When a <code>Entity</code> is terminated, its occupied resource will be automatically released.</p> <p>To distribute <code>Resource</code> to <code>Entity</code>, you could use either <code>distribute()</code> class function from <code>Resource</code> or <code>acquire()</code> class function from <code>Entity</code>. Note that if the required amount is larger than the current level of the resource, all remaining available amount will be given to the enity.</p> <p>Similar, to return/collect resource, you could user <code>collect()</code> class function from <code>Resource</code> or <code>release()</code> class function from <code>Entity</code>. If the amount is larger than the current occupied amount by the user, all occupied resource will be released/collected.</p> <pre><code>import asyncio\nfrom Akatosh.entity import Entity\nfrom Akatosh.event import event\nfrom Akatosh.resource import Resource\nfrom Akatosh.universe import universe\n\nres = Resource(100.0, 50.0)\n\nuser = Entity(0, 5, \"User\", priority=0)\n\n\n@user.event(1.2, 4, \"Use Resource\", priority=0)\ndef user_event():\n    if res.distribute(user, 1):\n        print(f\"Consumed {res.usage} resource.\")\n    else:\n        print(\"Not enough resource\")\n\n@event(2.0,2.0)\ndef collect_resource():\n    res.collect(user, 10)\n\n@event(5.0,5.0)\ndef check_resource():\n    print(f\"Resource: {res.level}\")\n\nuniverse.time_resolution=1\nasyncio.run(universe.simulate(6))\n</code></pre>"}]}