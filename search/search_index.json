{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Akatosh","text":"<p> <code>Akatosh</code> is a light-weighted disceret event simulation library. Unlike popular library <code>Simpy</code> which is progress-oriented and you have to write generator function for simulated events or events interaction, `Akatosh` is fully object-oriented that events are encapsulated as `InstantEvent`/`ContinousEvent` with states, priority and a life-cycle. The actual impact of events are simply regular python functions. You could create events all at once, or create event within event. In addition, `Akatosh` is async which means event that are happening at the same simulated time will be executed simultaneously for real, unless they have different priority. </p> <p> <code>Akatosh</code> also support <code>Resource</code>, provide all functionalities as it is in <code>Simpy</code> with extra utilities for telemetries collection and interaction with <code>Entity</code>. The <code>Entity</code> is unique to <code>Akatosh</code> which represents a abstract entity with a life-cycle, for example a follower. The <code>Entity</code> supports utility functions to interact with `Resource` and automatically releases all its occupied resources upon termination. </p> <p> You probably already noticed that <code>Akatosh</code> is the name of \"Dragon God of Time\" in elder scroll serie, therefore the singleton class <code>Mundus</code> is the core of the simulation. The <code>Mundus</code> will schedule the events, move forward time and engage async execution. </p> <p>To use <code>Akatosh</code>: <pre><code>pip install -U Akatosh\n</code></pre></p> <p>A basic example is showing below, for more information please look at Examples and API Reference</p> <pre><code>import logging\nfrom Akatosh import event, Mundus\n# create two instant event at simulation time 1.0 and 5.0\n@event(at=5)\ndef hellow_world_again():\nprint(f\"{Mundus.now}:\\tHello World! Again!\")\n@event(at=1)\ndef hellow_world():\nprint(f\"{Mundus.now}:\\tHello World!\")\n# enable debug message\nMundus.set_logger(logging.DEBUG)\n# run simulation for 6s\nMundus.simulate(6)\n</code></pre>"},{"location":"api/continuous_event/","title":"ContinuousEvent","text":"<p>         Bases: <code>Event</code></p> Source code in <code>Akatosh\\event.py</code> <pre><code>class ContinuousEvent(Event):\ndef __init__(\nself,\nat: int | float | Callable[..., Any],\ninterval: int | float | Callable[..., Any],\nduration: int | float | Callable[..., Any],\nprecursor: Event | List[Event] | None = None,\naction: Callable[..., Any] | None = None,\npriority: int | float | Callable[..., Any] = 0,\nlabel: str | None = None,\n**kwargs,\n) -&gt; None:\n\"\"\"Continous event is an event that happens at a specific time and happens multiple times for a specific duration.\n        Args:\n            at (int | float | Callable[..., Any]): when the event happens.\n            interval (int | float | Callable[..., Any]): the interval between each action repeat.\n            duration (int | float | Callable[..., Any]): the duration of the event.\n            precursor (Event | List[Event] | None, optional): the precursor events, can be both instant events or continous events. Defaults to None.\n            action (Callable[..., Any] | None, optional): the actual action of the event. Defaults to None.\n            priority (int | float | Callable[..., Any], optional): the priority of the event. Defaults to 0.\n            label (str | None, optional): short description of the event.. Defaults to None.\n        \"\"\"\nsuper().__init__(\nat=at,\nprecursor=precursor,\naction=action,\npriority=priority,\nlabel=label,\n**kwargs,\n)\nself._interval = interval\nif callable(duration):\nself._duration = round(duration(), Mundus.resolution)\nelse:\nself._duration = round(duration, Mundus.resolution)\nself._till = self.at + self.duration\nself._sub_events: List[InstantEvent] = list()\nasync def _perform(self):\n\"\"\"Perform the action of the event. Compare to instant event, continous event will perform the action multiple times.\"\"\"\nif self.action:\nself.action()\nif callable(self.interval):\nself._at = round(self.interval() + Mundus.now, Mundus.resolution)\nelse:\nself._at = round(self.interval + Mundus.now, Mundus.resolution)\nif self.at &lt;= self.till:\nlogger.debug(f\"Event {self.label} next step is at {self.at}.\")\nMundus.future_events.append(self)\nelse:\nlogger.debug(f\"Event {self.label} is ended.\")\nMundus.current_events.remove(self)\nMundus.past_events.append(self)\n@property\ndef interval(self) -&gt; int | float | Callable[..., Any]:\n\"\"\"Return the interval between each action repeat.\"\"\"\nreturn self._interval\n@property\ndef duration(self) -&gt; int | float:\n\"\"\"Return the duration of the event.\"\"\"\nreturn self._duration\n@property\ndef till(self) -&gt; int | float:\n\"\"\"Return the time when the event ends.\"\"\"\nreturn self._till\n@property\ndef sub_events(self) -&gt; List[InstantEvent]:\n\"\"\"Return the sub events of the continous event.\"\"\"\nreturn self._sub_events\n</code></pre>"},{"location":"api/continuous_event/#Akatosh.event.ContinuousEvent.duration","title":"<code>duration: int | float</code>  <code>property</code>","text":"<p>Return the duration of the event.</p>"},{"location":"api/continuous_event/#Akatosh.event.ContinuousEvent.interval","title":"<code>interval: int | float | Callable[..., Any]</code>  <code>property</code>","text":"<p>Return the interval between each action repeat.</p>"},{"location":"api/continuous_event/#Akatosh.event.ContinuousEvent.sub_events","title":"<code>sub_events: List[InstantEvent]</code>  <code>property</code>","text":"<p>Return the sub events of the continous event.</p>"},{"location":"api/continuous_event/#Akatosh.event.ContinuousEvent.till","title":"<code>till: int | float</code>  <code>property</code>","text":"<p>Return the time when the event ends.</p>"},{"location":"api/continuous_event/#Akatosh.event.ContinuousEvent.__init__","title":"<code>__init__(at, interval, duration, precursor=None, action=None, priority=0, label=None, **kwargs)</code>","text":"<p>Continous event is an event that happens at a specific time and happens multiple times for a specific duration.</p> <p>Parameters:</p> Name Type Description Default <code>at</code> <code>int | float | Callable[..., Any]</code> <p>when the event happens.</p> required <code>interval</code> <code>int | float | Callable[..., Any]</code> <p>the interval between each action repeat.</p> required <code>duration</code> <code>int | float | Callable[..., Any]</code> <p>the duration of the event.</p> required <code>precursor</code> <code>Event | List[Event] | None</code> <p>the precursor events, can be both instant events or continous events. Defaults to None.</p> <code>None</code> <code>action</code> <code>Callable[..., Any] | None</code> <p>the actual action of the event. Defaults to None.</p> <code>None</code> <code>priority</code> <code>int | float | Callable[..., Any]</code> <p>the priority of the event. Defaults to 0.</p> <code>0</code> <code>label</code> <code>str | None</code> <p>short description of the event.. Defaults to None.</p> <code>None</code> Source code in <code>Akatosh\\event.py</code> <pre><code>def __init__(\nself,\nat: int | float | Callable[..., Any],\ninterval: int | float | Callable[..., Any],\nduration: int | float | Callable[..., Any],\nprecursor: Event | List[Event] | None = None,\naction: Callable[..., Any] | None = None,\npriority: int | float | Callable[..., Any] = 0,\nlabel: str | None = None,\n**kwargs,\n) -&gt; None:\n\"\"\"Continous event is an event that happens at a specific time and happens multiple times for a specific duration.\n    Args:\n        at (int | float | Callable[..., Any]): when the event happens.\n        interval (int | float | Callable[..., Any]): the interval between each action repeat.\n        duration (int | float | Callable[..., Any]): the duration of the event.\n        precursor (Event | List[Event] | None, optional): the precursor events, can be both instant events or continous events. Defaults to None.\n        action (Callable[..., Any] | None, optional): the actual action of the event. Defaults to None.\n        priority (int | float | Callable[..., Any], optional): the priority of the event. Defaults to 0.\n        label (str | None, optional): short description of the event.. Defaults to None.\n    \"\"\"\nsuper().__init__(\nat=at,\nprecursor=precursor,\naction=action,\npriority=priority,\nlabel=label,\n**kwargs,\n)\nself._interval = interval\nif callable(duration):\nself._duration = round(duration(), Mundus.resolution)\nelse:\nself._duration = round(duration, Mundus.resolution)\nself._till = self.at + self.duration\nself._sub_events: List[InstantEvent] = list()\n</code></pre>"},{"location":"api/entity/","title":"Entity","text":"Source code in <code>Akatosh\\entity.py</code> <pre><code>class Entity:\ndef __init__(\nself,\nlabel: str | None = None,\ncreate_at: int | float | Callable | None = None,\nterminate_at: int | float | Callable | None = None,\n) -&gt; None:\n\"\"\"Create a entity.\n        Args:\n            label (str | None, optional): short description of the entity. Defaults to None.\n            create_at (int | float | Callable | None, optional): when the life cycle of this entity should start. Defaults to None, then must call create() method manually.\n            terminate_at (int | float | Callable | None, optional): when the life cycle of this entity should end. Defaults to None, then must call terminate() method manually.\n        \"\"\"\nself._id = uuid4().int\nself._label = label\nself._state: List[str] = list()\nself._occupied_resources: List[Resource] = list()\nself._creation: InstantEvent = None  # type: ignore\nself._termination: InstantEvent = None  # type: ignore\nif create_at is not None:\nif callable(create_at):\nself.create(at=round(create_at(), Mundus.resolution))\nelse:\nself.create(at=round(create_at, Mundus.resolution))\nif terminate_at is not None:\nif callable(terminate_at):\nself.terminate(at=round(terminate_at(), Mundus.resolution))\nelse:\nself.terminate(at=round(terminate_at, Mundus.resolution))\ndef create(self, at: int | float) -&gt; None:\n\"\"\"The creation of the entity.\"\"\"\ndef _create():\nif self.terminated:\nraise RuntimeError(f\"Entity {self.label} is already terminated.\")\nself._state.append(State.CREATED)\nself.on_creation()\nlogger.debug(f\"Entity {self.label} created at {Mundus.now}\")\nself._creation = InstantEvent(\nat=at, action=_create, label=f\"Creation of {self.label}\"\n)\n@abstractmethod\ndef on_creation(self):\n\"\"\"Callback function upon creation of the entity\"\"\"\npass\ndef terminate(self, at: int | float) -&gt; None:\n\"\"\"The termination of the entity.\"\"\"\ndef _terminate():\nif not self.created:\nraise RuntimeError(f\"Entity {self.label} is not created yet.\")\nself._state.append(State.TERMINATED)\nself.release_resources()\nself.on_termination()\nlogger.debug(f\"Entity {self.label} terminated at {Mundus.now}\")\nself._termination = InstantEvent(\nat=at, action=_terminate, label=f\"Termination of {self.label}\"\n)\n@abstractmethod\ndef on_termination(self):\n\"\"\"Callback function upon termination of the entity\"\"\"\npass\ndef get(\nself, resource: Resource, amount: int | float | Callable | None = None\n) -&gt; None:\n\"\"\"Consume certain amout from a resource. if no amount is specified, consume all.\"\"\"\nif amount:\nif callable(amount):\nresource.distribute(self, amount())\nself.ocupied_resources.append(resource)\nelse:\nresource.distribute(self, amount)\nself.ocupied_resources.append(resource)\nelse:\nresource.distribute(self, resource.amount)\ndef put(\nself, resource: Resource, amount: int | float | Callable | None = None\n) -&gt; None:\n\"\"\"Return certain amout to a resource. if no amount is specified, return all.\"\"\"\nif amount:\nif callable(amount):\nresource.collect(self, amount())\nif self not in resource.users:\nself.ocupied_resources.remove(resource)\nelse:\nresource.put(amount)\nif self not in resource.users:\nself.ocupied_resources.remove(resource)\nelse:\nresource.put(resource.amount)\ndef release_resources(self):\n\"\"\"Release all occupied resources.\"\"\"\nfor res in self.ocupied_resources:\nres.collect(self)\n@property\ndef label(self):\n\"\"\"Return the label of the entity.\"\"\"\nreturn self._label\n@property\ndef state(self):\n\"\"\"Return the state(s) of the entity.\"\"\"\nreturn self._state\n@property\ndef created(self):\n\"\"\"Return True if the entity is created.\"\"\"\nreturn State.CREATED in self.state\n@property\ndef terminated(self):\n\"\"\"Return True if the entity is terminated.\"\"\"\nreturn State.TERMINATED in self.state\n@property\ndef ocupied_resources(self):\n\"\"\"Return the resources occupied by the entity.\"\"\"\nreturn self._occupied_resources\n</code></pre>"},{"location":"api/entity/#Akatosh.entity.Entity.created","title":"<code>created</code>  <code>property</code>","text":"<p>Return True if the entity is created.</p>"},{"location":"api/entity/#Akatosh.entity.Entity.label","title":"<code>label</code>  <code>property</code>","text":"<p>Return the label of the entity.</p>"},{"location":"api/entity/#Akatosh.entity.Entity.ocupied_resources","title":"<code>ocupied_resources</code>  <code>property</code>","text":"<p>Return the resources occupied by the entity.</p>"},{"location":"api/entity/#Akatosh.entity.Entity.state","title":"<code>state</code>  <code>property</code>","text":"<p>Return the state(s) of the entity.</p>"},{"location":"api/entity/#Akatosh.entity.Entity.terminated","title":"<code>terminated</code>  <code>property</code>","text":"<p>Return True if the entity is terminated.</p>"},{"location":"api/entity/#Akatosh.entity.Entity.__init__","title":"<code>__init__(label=None, create_at=None, terminate_at=None)</code>","text":"<p>Create a entity.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str | None</code> <p>short description of the entity. Defaults to None.</p> <code>None</code> <code>create_at</code> <code>int | float | Callable | None</code> <p>when the life cycle of this entity should start. Defaults to None, then must call create() method manually.</p> <code>None</code> <code>terminate_at</code> <code>int | float | Callable | None</code> <p>when the life cycle of this entity should end. Defaults to None, then must call terminate() method manually.</p> <code>None</code> Source code in <code>Akatosh\\entity.py</code> <pre><code>def __init__(\nself,\nlabel: str | None = None,\ncreate_at: int | float | Callable | None = None,\nterminate_at: int | float | Callable | None = None,\n) -&gt; None:\n\"\"\"Create a entity.\n    Args:\n        label (str | None, optional): short description of the entity. Defaults to None.\n        create_at (int | float | Callable | None, optional): when the life cycle of this entity should start. Defaults to None, then must call create() method manually.\n        terminate_at (int | float | Callable | None, optional): when the life cycle of this entity should end. Defaults to None, then must call terminate() method manually.\n    \"\"\"\nself._id = uuid4().int\nself._label = label\nself._state: List[str] = list()\nself._occupied_resources: List[Resource] = list()\nself._creation: InstantEvent = None  # type: ignore\nself._termination: InstantEvent = None  # type: ignore\nif create_at is not None:\nif callable(create_at):\nself.create(at=round(create_at(), Mundus.resolution))\nelse:\nself.create(at=round(create_at, Mundus.resolution))\nif terminate_at is not None:\nif callable(terminate_at):\nself.terminate(at=round(terminate_at(), Mundus.resolution))\nelse:\nself.terminate(at=round(terminate_at, Mundus.resolution))\n</code></pre>"},{"location":"api/entity/#Akatosh.entity.Entity.create","title":"<code>create(at)</code>","text":"<p>The creation of the entity.</p> Source code in <code>Akatosh\\entity.py</code> <pre><code>def create(self, at: int | float) -&gt; None:\n\"\"\"The creation of the entity.\"\"\"\ndef _create():\nif self.terminated:\nraise RuntimeError(f\"Entity {self.label} is already terminated.\")\nself._state.append(State.CREATED)\nself.on_creation()\nlogger.debug(f\"Entity {self.label} created at {Mundus.now}\")\nself._creation = InstantEvent(\nat=at, action=_create, label=f\"Creation of {self.label}\"\n)\n</code></pre>"},{"location":"api/entity/#Akatosh.entity.Entity.get","title":"<code>get(resource, amount=None)</code>","text":"<p>Consume certain amout from a resource. if no amount is specified, consume all.</p> Source code in <code>Akatosh\\entity.py</code> <pre><code>def get(\nself, resource: Resource, amount: int | float | Callable | None = None\n) -&gt; None:\n\"\"\"Consume certain amout from a resource. if no amount is specified, consume all.\"\"\"\nif amount:\nif callable(amount):\nresource.distribute(self, amount())\nself.ocupied_resources.append(resource)\nelse:\nresource.distribute(self, amount)\nself.ocupied_resources.append(resource)\nelse:\nresource.distribute(self, resource.amount)\n</code></pre>"},{"location":"api/entity/#Akatosh.entity.Entity.on_creation","title":"<code>on_creation()</code>  <code>abstractmethod</code>","text":"<p>Callback function upon creation of the entity</p> Source code in <code>Akatosh\\entity.py</code> <pre><code>@abstractmethod\ndef on_creation(self):\n\"\"\"Callback function upon creation of the entity\"\"\"\npass\n</code></pre>"},{"location":"api/entity/#Akatosh.entity.Entity.on_termination","title":"<code>on_termination()</code>  <code>abstractmethod</code>","text":"<p>Callback function upon termination of the entity</p> Source code in <code>Akatosh\\entity.py</code> <pre><code>@abstractmethod\ndef on_termination(self):\n\"\"\"Callback function upon termination of the entity\"\"\"\npass\n</code></pre>"},{"location":"api/entity/#Akatosh.entity.Entity.put","title":"<code>put(resource, amount=None)</code>","text":"<p>Return certain amout to a resource. if no amount is specified, return all.</p> Source code in <code>Akatosh\\entity.py</code> <pre><code>def put(\nself, resource: Resource, amount: int | float | Callable | None = None\n) -&gt; None:\n\"\"\"Return certain amout to a resource. if no amount is specified, return all.\"\"\"\nif amount:\nif callable(amount):\nresource.collect(self, amount())\nif self not in resource.users:\nself.ocupied_resources.remove(resource)\nelse:\nresource.put(amount)\nif self not in resource.users:\nself.ocupied_resources.remove(resource)\nelse:\nresource.put(resource.amount)\n</code></pre>"},{"location":"api/entity/#Akatosh.entity.Entity.release_resources","title":"<code>release_resources()</code>","text":"<p>Release all occupied resources.</p> Source code in <code>Akatosh\\entity.py</code> <pre><code>def release_resources(self):\n\"\"\"Release all occupied resources.\"\"\"\nfor res in self.ocupied_resources:\nres.collect(self)\n</code></pre>"},{"location":"api/entity/#Akatosh.entity.Entity.terminate","title":"<code>terminate(at)</code>","text":"<p>The termination of the entity.</p> Source code in <code>Akatosh\\entity.py</code> <pre><code>def terminate(self, at: int | float) -&gt; None:\n\"\"\"The termination of the entity.\"\"\"\ndef _terminate():\nif not self.created:\nraise RuntimeError(f\"Entity {self.label} is not created yet.\")\nself._state.append(State.TERMINATED)\nself.release_resources()\nself.on_termination()\nlogger.debug(f\"Entity {self.label} terminated at {Mundus.now}\")\nself._termination = InstantEvent(\nat=at, action=_terminate, label=f\"Termination of {self.label}\"\n)\n</code></pre>"},{"location":"api/event/","title":"Event","text":"Source code in <code>Akatosh\\event.py</code> <pre><code>class Event:\ndef __init__(\nself,\nat: int | float | Callable,\nprecursor: Event | List[Event] | None = None,\naction: Callable | None = None,\npriority: int | float | Callable = 0,\nlabel: str | None = None,\n**kwargs,\n) -&gt; None:\n\"\"\"Base class for all events.\n        Args:\n            at (int | float | Callable): the time when the event happens.\n            precursor (Event | List[Event] | None, optional): the precursor events. Defaults to None.\n            action (Callable | None, optional): the actual action of the event, must be defined. Defaults to None.\n            priority (int | float | Callable, optional): the priority of the event. When multiple event happen at the same time, the event with lower priority value will happen first. Defaults to 0.\n            label (str | None, optional): Short descirption of the event. Defaults to None.\n        \"\"\"\nself._id = uuid4().int\n# set the time\nif callable(at):\nself._at = round(at(), Mundus.resolution)\nelse:\nself._at = round(at, Mundus.resolution)\n# set the target event(s) that this event should wait and follow\nif isinstance(precursor, list):\nself._precursor = precursor\nelse:\nself._precursor = [precursor] if precursor is not None else []\nself._follower: List[Event] = []\nfor event in self.precursor:\nevent._follower.append(self)\n# set the state\nif precursor:\nself.state = State.INACTIVE\nelse:\nself.state = State.ACTIVE\n# set the action and the priority\nif action:\nself._action = action\nif callable(priority):\nself._priority = priority()\nelse:\nself._priority = priority\n# assign label\nself._label = label\n# add to the universe\nMundus.future_events.append(self)\ndef end(self):\n\"\"\"End the event and activate the follower events if there is any.\"\"\"\nself.state = State.ENDED\nfor event in self.follower:\ntry:\nevent.activate()\nexcept RuntimeError:\nlogger.debug(f\"Event {event.label} passed due time.\")\ndef activate(self, force: bool = False):\nif self.ended:\nraise RuntimeError(f\"Event {self.label} has already ended.\")\nif force:\nself.state = State.ACTIVE\nlogger.debug(f\"Event {self.label} is set to active.\")\nelse:\nif all(e.state == State.ENDED for e in self.precursor):\nself.state = State.ACTIVE\nlogger.debug(f\"Event {self.label} is set to active.\")\nelse:\nraise RuntimeError(\nf\"Event {self.label} is waiting for other events to end.\"\n)\ndef deactivate(self):\n\"\"\"Deactivate the event.\n        Raises:\n            RuntimeError: raise if the event has already ended.\n        \"\"\"\nif self.ended:\nraise RuntimeError(f\"Event {self.label} has already ended.\")\nself.state = State.INACTIVE\ndef cancel(self):\n\"\"\"Cancel the event.\n        Raises:\n            RuntimeError: raise if the event has already ended.\n        \"\"\"\nif self.ended:\nraise RuntimeError(f\"Event {self.label} has already ended.\")\nself.state = State.CANCELED\n@abstractmethod\nasync def _perform(self):\n\"\"\"Abstract method for the event to perform its action.\"\"\"\npass\ndef __eq__(self, _o: Event) -&gt; bool:\n\"\"\"Determine if two events are the same.\"\"\"\nreturn self.id == _o.id\n@property\ndef id(self) -&gt; int:\n\"\"\"Return the unique id of the event.\"\"\"\nreturn self._id\n@property\ndef label(self) -&gt; str | None:\n\"\"\"Return the label of the event.\"\"\"\nreturn self._label\n@property\ndef at(self) -&gt; int | float:\n\"\"\"Return the time when the event happens.\"\"\"\nreturn self._at\n@property\ndef precursor(self) -&gt; List[Event]:\n\"\"\"Return the precursor events.\"\"\"\nreturn self._precursor\n@property\ndef follower(self) -&gt; List[Event]:\n\"\"\"Return the follower events.\"\"\"\nreturn self._follower\n@property\ndef action(self) -&gt; Callable | None:\n\"\"\"Return the action of the event.\"\"\"\nreturn self._action\n@property\ndef priority(self) -&gt; int | float:\n\"\"\"Return the priority of the event.\"\"\"\nreturn self._priority\n@property\ndef state(self) -&gt; str:\n\"\"\"Return the state of the event.\"\"\"\nreturn self._state\n@state.setter\ndef state(self, state: str):\n\"\"\"Set the state of the event.\"\"\"\nself._state = state\n@property\ndef active(self) -&gt; bool:\n\"\"\"Return True if the event is active.\"\"\"\nreturn State.ACTIVE == self.state\n@property\ndef inactive(self) -&gt; bool:\n\"\"\"Return True if the event is inactive.\"\"\"\nreturn State.INACTIVE == self.state\n@property\ndef cancelled(self) -&gt; bool:\n\"\"\"Return True if the event is cancelled.\"\"\"\nreturn State.CANCELED == self.state\n@property\ndef ended(self) -&gt; bool:\n\"\"\"Return True if the event is ended.\"\"\"\nreturn State.ENDED == self.state\n</code></pre>"},{"location":"api/event/#Akatosh.event.Event.action","title":"<code>action: Callable | None</code>  <code>property</code>","text":"<p>Return the action of the event.</p>"},{"location":"api/event/#Akatosh.event.Event.active","title":"<code>active: bool</code>  <code>property</code>","text":"<p>Return True if the event is active.</p>"},{"location":"api/event/#Akatosh.event.Event.at","title":"<code>at: int | float</code>  <code>property</code>","text":"<p>Return the time when the event happens.</p>"},{"location":"api/event/#Akatosh.event.Event.cancelled","title":"<code>cancelled: bool</code>  <code>property</code>","text":"<p>Return True if the event is cancelled.</p>"},{"location":"api/event/#Akatosh.event.Event.ended","title":"<code>ended: bool</code>  <code>property</code>","text":"<p>Return True if the event is ended.</p>"},{"location":"api/event/#Akatosh.event.Event.follower","title":"<code>follower: List[Event]</code>  <code>property</code>","text":"<p>Return the follower events.</p>"},{"location":"api/event/#Akatosh.event.Event.id","title":"<code>id: int</code>  <code>property</code>","text":"<p>Return the unique id of the event.</p>"},{"location":"api/event/#Akatosh.event.Event.inactive","title":"<code>inactive: bool</code>  <code>property</code>","text":"<p>Return True if the event is inactive.</p>"},{"location":"api/event/#Akatosh.event.Event.label","title":"<code>label: str | None</code>  <code>property</code>","text":"<p>Return the label of the event.</p>"},{"location":"api/event/#Akatosh.event.Event.precursor","title":"<code>precursor: List[Event]</code>  <code>property</code>","text":"<p>Return the precursor events.</p>"},{"location":"api/event/#Akatosh.event.Event.priority","title":"<code>priority: int | float</code>  <code>property</code>","text":"<p>Return the priority of the event.</p>"},{"location":"api/event/#Akatosh.event.Event.state","title":"<code>state: str</code>  <code>writable</code> <code>property</code>","text":"<p>Return the state of the event.</p>"},{"location":"api/event/#Akatosh.event.Event.__eq__","title":"<code>__eq__(_o)</code>","text":"<p>Determine if two events are the same.</p> Source code in <code>Akatosh\\event.py</code> <pre><code>def __eq__(self, _o: Event) -&gt; bool:\n\"\"\"Determine if two events are the same.\"\"\"\nreturn self.id == _o.id\n</code></pre>"},{"location":"api/event/#Akatosh.event.Event.__init__","title":"<code>__init__(at, precursor=None, action=None, priority=0, label=None, **kwargs)</code>","text":"<p>Base class for all events.</p> <p>Parameters:</p> Name Type Description Default <code>at</code> <code>int | float | Callable</code> <p>the time when the event happens.</p> required <code>precursor</code> <code>Event | List[Event] | None</code> <p>the precursor events. Defaults to None.</p> <code>None</code> <code>action</code> <code>Callable | None</code> <p>the actual action of the event, must be defined. Defaults to None.</p> <code>None</code> <code>priority</code> <code>int | float | Callable</code> <p>the priority of the event. When multiple event happen at the same time, the event with lower priority value will happen first. Defaults to 0.</p> <code>0</code> <code>label</code> <code>str | None</code> <p>Short descirption of the event. Defaults to None.</p> <code>None</code> Source code in <code>Akatosh\\event.py</code> <pre><code>def __init__(\nself,\nat: int | float | Callable,\nprecursor: Event | List[Event] | None = None,\naction: Callable | None = None,\npriority: int | float | Callable = 0,\nlabel: str | None = None,\n**kwargs,\n) -&gt; None:\n\"\"\"Base class for all events.\n    Args:\n        at (int | float | Callable): the time when the event happens.\n        precursor (Event | List[Event] | None, optional): the precursor events. Defaults to None.\n        action (Callable | None, optional): the actual action of the event, must be defined. Defaults to None.\n        priority (int | float | Callable, optional): the priority of the event. When multiple event happen at the same time, the event with lower priority value will happen first. Defaults to 0.\n        label (str | None, optional): Short descirption of the event. Defaults to None.\n    \"\"\"\nself._id = uuid4().int\n# set the time\nif callable(at):\nself._at = round(at(), Mundus.resolution)\nelse:\nself._at = round(at, Mundus.resolution)\n# set the target event(s) that this event should wait and follow\nif isinstance(precursor, list):\nself._precursor = precursor\nelse:\nself._precursor = [precursor] if precursor is not None else []\nself._follower: List[Event] = []\nfor event in self.precursor:\nevent._follower.append(self)\n# set the state\nif precursor:\nself.state = State.INACTIVE\nelse:\nself.state = State.ACTIVE\n# set the action and the priority\nif action:\nself._action = action\nif callable(priority):\nself._priority = priority()\nelse:\nself._priority = priority\n# assign label\nself._label = label\n# add to the universe\nMundus.future_events.append(self)\n</code></pre>"},{"location":"api/event/#Akatosh.event.Event.cancel","title":"<code>cancel()</code>","text":"<p>Cancel the event.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>raise if the event has already ended.</p> Source code in <code>Akatosh\\event.py</code> <pre><code>def cancel(self):\n\"\"\"Cancel the event.\n    Raises:\n        RuntimeError: raise if the event has already ended.\n    \"\"\"\nif self.ended:\nraise RuntimeError(f\"Event {self.label} has already ended.\")\nself.state = State.CANCELED\n</code></pre>"},{"location":"api/event/#Akatosh.event.Event.deactivate","title":"<code>deactivate()</code>","text":"<p>Deactivate the event.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>raise if the event has already ended.</p> Source code in <code>Akatosh\\event.py</code> <pre><code>def deactivate(self):\n\"\"\"Deactivate the event.\n    Raises:\n        RuntimeError: raise if the event has already ended.\n    \"\"\"\nif self.ended:\nraise RuntimeError(f\"Event {self.label} has already ended.\")\nself.state = State.INACTIVE\n</code></pre>"},{"location":"api/event/#Akatosh.event.Event.end","title":"<code>end()</code>","text":"<p>End the event and activate the follower events if there is any.</p> Source code in <code>Akatosh\\event.py</code> <pre><code>def end(self):\n\"\"\"End the event and activate the follower events if there is any.\"\"\"\nself.state = State.ENDED\nfor event in self.follower:\ntry:\nevent.activate()\nexcept RuntimeError:\nlogger.debug(f\"Event {event.label} passed due time.\")\n</code></pre>"},{"location":"api/instant_event/","title":"InstantEvent","text":"<p>         Bases: <code>Event</code></p> <p>Instant event is an event that happens at a specific time and only happens once.</p> Source code in <code>Akatosh\\event.py</code> <pre><code>class InstantEvent(Event):\n\"\"\"Instant event is an event that happens at a specific time and only happens once.\"\"\"\ndef __init__(\nself,\nat: int | float | Callable[..., Any],\nprecursor: Event | List[Event] | None = None,\naction: Callable[..., Any] | None = None,\npriority: int | float | Callable[..., Any] = 0,\nlabel: str | None = None,\n**kwargs,\n) -&gt; None:\n\"\"\"Create a instant event.\n        Args:\n            at (int | float | Callable): the time when the event happens.\n            precursor (Event | List[Event] | None, optional): the precursor events. Defaults to None.\n            action (Callable | None, optional): the actual action of the event, must be defined. Defaults to None.\n            priority (int | float | Callable, optional): the priority of the event. When multiple event happen at the same time, the event with lower priority value will happen first. Defaults to 0.\n            label (str | None, optional): Short descirption of the event. Defaults to None.\n        \"\"\"\nsuper().__init__(at, precursor, action, priority, label, **kwargs)\nasync def _perform(self):\n\"\"\"Perform the action of the event.\"\"\"\nif self.state == State.ACTIVE:\nif self.action:\nif inspect.iscoroutinefunction(self.action):\nawait self.action()\nelse:\nself.action()\nMundus.current_events.remove(self)\nMundus.past_events.append(self)\nself.end()\nlogger.debug(f\"Event {self.label} is ended.\")\n</code></pre>"},{"location":"api/instant_event/#Akatosh.event.InstantEvent.__init__","title":"<code>__init__(at, precursor=None, action=None, priority=0, label=None, **kwargs)</code>","text":"<p>Create a instant event.</p> <p>Parameters:</p> Name Type Description Default <code>at</code> <code>int | float | Callable</code> <p>the time when the event happens.</p> required <code>precursor</code> <code>Event | List[Event] | None</code> <p>the precursor events. Defaults to None.</p> <code>None</code> <code>action</code> <code>Callable | None</code> <p>the actual action of the event, must be defined. Defaults to None.</p> <code>None</code> <code>priority</code> <code>int | float | Callable</code> <p>the priority of the event. When multiple event happen at the same time, the event with lower priority value will happen first. Defaults to 0.</p> <code>0</code> <code>label</code> <code>str | None</code> <p>Short descirption of the event. Defaults to None.</p> <code>None</code> Source code in <code>Akatosh\\event.py</code> <pre><code>def __init__(\nself,\nat: int | float | Callable[..., Any],\nprecursor: Event | List[Event] | None = None,\naction: Callable[..., Any] | None = None,\npriority: int | float | Callable[..., Any] = 0,\nlabel: str | None = None,\n**kwargs,\n) -&gt; None:\n\"\"\"Create a instant event.\n    Args:\n        at (int | float | Callable): the time when the event happens.\n        precursor (Event | List[Event] | None, optional): the precursor events. Defaults to None.\n        action (Callable | None, optional): the actual action of the event, must be defined. Defaults to None.\n        priority (int | float | Callable, optional): the priority of the event. When multiple event happen at the same time, the event with lower priority value will happen first. Defaults to 0.\n        label (str | None, optional): Short descirption of the event. Defaults to None.\n    \"\"\"\nsuper().__init__(at, precursor, action, priority, label, **kwargs)\n</code></pre>"},{"location":"api/resource/","title":"Resource","text":"Source code in <code>Akatosh\\resource.py</code> <pre><code>class Resource:\ndef __init__(\nself,\ncapacity: int | float | Callable,\ninitial_amount: int | float | Callable | None = None,\nlabel: str | None = None,\n) -&gt; None:\n\"\"\"Resource is a class that represents a resource with capacity and amount, any object can use this resource by calling distribute() and return by calling collect() methods.\n        Args:\n            capacity (int | float | Callable): the capacity of the resource.\n            initial_amount (int | float | Callable | None, optional): the initial amount of the resource. Defaults to capacity.\n            label (str | None, optional): short description of the resource. Defaults to None.\n        Raises:\n            ValueError: raise if initial amount is greater than capacity.\n        \"\"\"\nif callable(capacity):\nself._capacity = capacity()\nelse:\nself._capacity = capacity\nif initial_amount:\nif callable(initial_amount):\nif initial_amount() &gt; self.capacity:\nraise ValueError(\"Initial amount is greater than capacity.\")\nelse:\nself._amount = initial_amount()\nelse:\nif initial_amount &gt; self.capacity:\nraise ValueError(\"Initial amount is greater than capacity.\")\nelse:\nself._amount = initial_amount\nelse:\nself._amount = self.capacity\nself._label = label\nself._user_records: List[Tuple[object, int | float]] = list() # (user, amount) tracking the usage of individual user\nself._usage_records: List[Tuple[int | float, int | float]] = list() # (time, amount) tracking the usage of the resource over time\ndef get(self, amount: int | float) -&gt; None:\n\"\"\"Get the amount of resource from the resource.\n        Args:\n            amount (int | float): the amount of resource to get.\n        Raises:\n            ValueError: raise if amount is greater than the current available amount of resource.\n        \"\"\"        \nif amount &gt; self.amount:\nraise ValueError(f\"Not enough amount in Resource {self.label}.\")\nelse:\nself._amount -= amount\nself.usage_records.append((Mundus.now, self.amount))\ndef put(self, amount: int | float) -&gt; None:\n\"\"\"Put the amount of resource back to the resource.\n        Args:\n            amount (int | float): the amount of resource to put.\n        Raises:\n            ValueError: raise if amount is greater than the current used amount of resource.\n        \"\"\"        \nif amount &gt; self.occupied:\nraise ValueError(f\"Not enough capacity in Resource {self.label}.\")\nelse:\nself._amount += amount\nself.usage_records.append((Mundus.now, self.amount))\ndef distribute(self, user: object, amount: int | float) -&gt; None:\n\"\"\"Distribute the amount of resource to the user.\n        Args:\n            user (object): the user of the resource.\n            amount (int | float): the amount of resource to distribute.\n        Raises:\n            ValueError: raise if amount is greater than the current available amount of resource.\n        \"\"\"        \nif amount &gt; self.amount:\nraise ValueError(f\"Not enough amount in Resource {self.label}.\")\nelse:\nself._amount -= amount\nif user in self.users:\nfor index, record in enumerate(self.user_records):\nif record[0] is user:\nself.user_records[index] = (user, record[1] + amount)\nbreak\nelse:\nself.user_records.append((user, amount))\nself.usage_records.append((Mundus.now, self.amount))\nlogger.debug(f\"Resource {self.label} distributed {amount} to {user}.\")\ndef collect(self, user: object, amount: int | float | None = None) -&gt; None:\n\"\"\"Collect the amount of resource from the user.\n        Args:\n            user (object): the user of the resource.\n            amount (int | float | None, optional): the amount of resource to collect. Defaults to None means collecting all resource used by the user.\n        Raises:\n            ValueError: raise if user is not using the resource or amount is greater than the current used amount of resource.\n        \"\"\"        \nif user not in self.users:\nraise ValueError(f\"User {user} is not using Resource {self.label}.\")\nif amount is None:\nfor index, record in enumerate(self.user_records):\nif record[0] is user:\nself._amount += record[1]\nself.usage_records.append((Mundus.now, self.amount))\nlogger.debug(\nf\"Resource {self.label} collected {record[1]} from {user}.\"\n)\nbreak\nelse:\nfor index, record in enumerate(self.user_records):\nif record[0] is user:\nif record[1] &lt; amount:\nraise ValueError(\nf\"{user} occupied {record[1]} of Resource {self.label}, less than {amount}.\"\n)\nelse:\nself.user_records[index] = (user, record[1] - amount)\nif self.user_records[index][1] == 0:\nself.user_records.pop(index)\nself._amount += amount\nself.usage_records.append((Mundus.now, self.amount))\nlogger.debug(\nf\"Resource {self.label} collected {amount} from {user}.\"\n)\nbreak\ndef usage(self, duration: int | float | Callable | None = None):\n\"\"\"Return the usage of the resource in the duration.\n        Args:\n            duration (int | float | Callable | None, optional): the duration to trace back in time. Defaults to None.\n        \"\"\"        \nif duration:\nif callable(duration):\nafter = Mundus.now - duration()\nelse:\nafter = Mundus.now - duration\nif after &lt; 0:\nafter = 0\nusage_records = [\nusage_record\nfor usage_record in self.usage_records\nif usage_record[0] &gt;= after\n]\nif len(usage_records) == 0:\nreturn 1 - (self.amount / self.capacity)\nelse:\nif usage_records[-1][0] - after == 0:\nreturn 1 - (usage_records[-1][1] / self.capacity)\nelse:\nweighted_overall_amount = 0\nfor index, record in enumerate(usage_records):\nif index == 0:\nweighted_overall_amount += record[1] * (record[0] - after)\nelif index == len(usage_records) - 1:\nweighted_overall_amount += record[1] * (\nMundus.now - usage_records[index - 1][0]\n)\nelse:\nweighted_overall_amount += record[1] * (\nrecord[0] - usage_records[index - 1][0]\n)\nreturn 1 - (\nweighted_overall_amount / (usage_records[-1][0] - after)\n)\nelse:\nreturn 1 - (self.amount / self.capacity)\n@property\ndef amount(self) -&gt; int | float:\n\"\"\"Return the current available amount of the resource.\"\"\"\nreturn self._amount\n@property\ndef capacity(self) -&gt; int | float:\n\"\"\"Return the capacity of the resource.\"\"\"\nreturn self._capacity\n@property\ndef occupied(self) -&gt; int | float:\n\"\"\"Return the current occupied amount of the resource.\"\"\"\nreturn self.capacity - self.amount\n@property\ndef label(self) -&gt; str | None:\n\"\"\"Return the label of the resource.\"\"\"\nreturn self._label\n@property\ndef user_records(self) -&gt; List[Tuple[object, int | float]]:\n\"\"\"Return the usage records of the resource per user.\"\"\"\nreturn self._user_records\n@property\ndef usage_records(self) -&gt; List[Tuple[int | float, int | float]]:\n\"\"\"Return the usage records of the resource, for calculating the usage of the resource in a duration.\"\"\"\nreturn self._usage_records\n@property\ndef users(self) -&gt; List[object]:\n\"\"\"Return the users of the resource.\"\"\"\nreturn [record[0] for record in self._user_records]\n</code></pre>"},{"location":"api/resource/#Akatosh.resource.Resource.amount","title":"<code>amount: int | float</code>  <code>property</code>","text":"<p>Return the current available amount of the resource.</p>"},{"location":"api/resource/#Akatosh.resource.Resource.capacity","title":"<code>capacity: int | float</code>  <code>property</code>","text":"<p>Return the capacity of the resource.</p>"},{"location":"api/resource/#Akatosh.resource.Resource.label","title":"<code>label: str | None</code>  <code>property</code>","text":"<p>Return the label of the resource.</p>"},{"location":"api/resource/#Akatosh.resource.Resource.occupied","title":"<code>occupied: int | float</code>  <code>property</code>","text":"<p>Return the current occupied amount of the resource.</p>"},{"location":"api/resource/#Akatosh.resource.Resource.usage_records","title":"<code>usage_records: List[Tuple[int | float, int | float]]</code>  <code>property</code>","text":"<p>Return the usage records of the resource, for calculating the usage of the resource in a duration.</p>"},{"location":"api/resource/#Akatosh.resource.Resource.user_records","title":"<code>user_records: List[Tuple[object, int | float]]</code>  <code>property</code>","text":"<p>Return the usage records of the resource per user.</p>"},{"location":"api/resource/#Akatosh.resource.Resource.users","title":"<code>users: List[object]</code>  <code>property</code>","text":"<p>Return the users of the resource.</p>"},{"location":"api/resource/#Akatosh.resource.Resource.__init__","title":"<code>__init__(capacity, initial_amount=None, label=None)</code>","text":"<p>Resource is a class that represents a resource with capacity and amount, any object can use this resource by calling distribute() and return by calling collect() methods.</p> <p>Parameters:</p> Name Type Description Default <code>capacity</code> <code>int | float | Callable</code> <p>the capacity of the resource.</p> required <code>initial_amount</code> <code>int | float | Callable | None</code> <p>the initial amount of the resource. Defaults to capacity.</p> <code>None</code> <code>label</code> <code>str | None</code> <p>short description of the resource. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>raise if initial amount is greater than capacity.</p> Source code in <code>Akatosh\\resource.py</code> <pre><code>def __init__(\nself,\ncapacity: int | float | Callable,\ninitial_amount: int | float | Callable | None = None,\nlabel: str | None = None,\n) -&gt; None:\n\"\"\"Resource is a class that represents a resource with capacity and amount, any object can use this resource by calling distribute() and return by calling collect() methods.\n    Args:\n        capacity (int | float | Callable): the capacity of the resource.\n        initial_amount (int | float | Callable | None, optional): the initial amount of the resource. Defaults to capacity.\n        label (str | None, optional): short description of the resource. Defaults to None.\n    Raises:\n        ValueError: raise if initial amount is greater than capacity.\n    \"\"\"\nif callable(capacity):\nself._capacity = capacity()\nelse:\nself._capacity = capacity\nif initial_amount:\nif callable(initial_amount):\nif initial_amount() &gt; self.capacity:\nraise ValueError(\"Initial amount is greater than capacity.\")\nelse:\nself._amount = initial_amount()\nelse:\nif initial_amount &gt; self.capacity:\nraise ValueError(\"Initial amount is greater than capacity.\")\nelse:\nself._amount = initial_amount\nelse:\nself._amount = self.capacity\nself._label = label\nself._user_records: List[Tuple[object, int | float]] = list() # (user, amount) tracking the usage of individual user\nself._usage_records: List[Tuple[int | float, int | float]] = list() # (time, amount) tracking the usage of the resource over time\n</code></pre>"},{"location":"api/resource/#Akatosh.resource.Resource.collect","title":"<code>collect(user, amount=None)</code>","text":"<p>Collect the amount of resource from the user.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>object</code> <p>the user of the resource.</p> required <code>amount</code> <code>int | float | None</code> <p>the amount of resource to collect. Defaults to None means collecting all resource used by the user.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>raise if user is not using the resource or amount is greater than the current used amount of resource.</p> Source code in <code>Akatosh\\resource.py</code> <pre><code>def collect(self, user: object, amount: int | float | None = None) -&gt; None:\n\"\"\"Collect the amount of resource from the user.\n    Args:\n        user (object): the user of the resource.\n        amount (int | float | None, optional): the amount of resource to collect. Defaults to None means collecting all resource used by the user.\n    Raises:\n        ValueError: raise if user is not using the resource or amount is greater than the current used amount of resource.\n    \"\"\"        \nif user not in self.users:\nraise ValueError(f\"User {user} is not using Resource {self.label}.\")\nif amount is None:\nfor index, record in enumerate(self.user_records):\nif record[0] is user:\nself._amount += record[1]\nself.usage_records.append((Mundus.now, self.amount))\nlogger.debug(\nf\"Resource {self.label} collected {record[1]} from {user}.\"\n)\nbreak\nelse:\nfor index, record in enumerate(self.user_records):\nif record[0] is user:\nif record[1] &lt; amount:\nraise ValueError(\nf\"{user} occupied {record[1]} of Resource {self.label}, less than {amount}.\"\n)\nelse:\nself.user_records[index] = (user, record[1] - amount)\nif self.user_records[index][1] == 0:\nself.user_records.pop(index)\nself._amount += amount\nself.usage_records.append((Mundus.now, self.amount))\nlogger.debug(\nf\"Resource {self.label} collected {amount} from {user}.\"\n)\nbreak\n</code></pre>"},{"location":"api/resource/#Akatosh.resource.Resource.distribute","title":"<code>distribute(user, amount)</code>","text":"<p>Distribute the amount of resource to the user.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>object</code> <p>the user of the resource.</p> required <code>amount</code> <code>int | float</code> <p>the amount of resource to distribute.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>raise if amount is greater than the current available amount of resource.</p> Source code in <code>Akatosh\\resource.py</code> <pre><code>def distribute(self, user: object, amount: int | float) -&gt; None:\n\"\"\"Distribute the amount of resource to the user.\n    Args:\n        user (object): the user of the resource.\n        amount (int | float): the amount of resource to distribute.\n    Raises:\n        ValueError: raise if amount is greater than the current available amount of resource.\n    \"\"\"        \nif amount &gt; self.amount:\nraise ValueError(f\"Not enough amount in Resource {self.label}.\")\nelse:\nself._amount -= amount\nif user in self.users:\nfor index, record in enumerate(self.user_records):\nif record[0] is user:\nself.user_records[index] = (user, record[1] + amount)\nbreak\nelse:\nself.user_records.append((user, amount))\nself.usage_records.append((Mundus.now, self.amount))\nlogger.debug(f\"Resource {self.label} distributed {amount} to {user}.\")\n</code></pre>"},{"location":"api/resource/#Akatosh.resource.Resource.get","title":"<code>get(amount)</code>","text":"<p>Get the amount of resource from the resource.</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>int | float</code> <p>the amount of resource to get.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>raise if amount is greater than the current available amount of resource.</p> Source code in <code>Akatosh\\resource.py</code> <pre><code>def get(self, amount: int | float) -&gt; None:\n\"\"\"Get the amount of resource from the resource.\n    Args:\n        amount (int | float): the amount of resource to get.\n    Raises:\n        ValueError: raise if amount is greater than the current available amount of resource.\n    \"\"\"        \nif amount &gt; self.amount:\nraise ValueError(f\"Not enough amount in Resource {self.label}.\")\nelse:\nself._amount -= amount\nself.usage_records.append((Mundus.now, self.amount))\n</code></pre>"},{"location":"api/resource/#Akatosh.resource.Resource.put","title":"<code>put(amount)</code>","text":"<p>Put the amount of resource back to the resource.</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>int | float</code> <p>the amount of resource to put.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>raise if amount is greater than the current used amount of resource.</p> Source code in <code>Akatosh\\resource.py</code> <pre><code>def put(self, amount: int | float) -&gt; None:\n\"\"\"Put the amount of resource back to the resource.\n    Args:\n        amount (int | float): the amount of resource to put.\n    Raises:\n        ValueError: raise if amount is greater than the current used amount of resource.\n    \"\"\"        \nif amount &gt; self.occupied:\nraise ValueError(f\"Not enough capacity in Resource {self.label}.\")\nelse:\nself._amount += amount\nself.usage_records.append((Mundus.now, self.amount))\n</code></pre>"},{"location":"api/resource/#Akatosh.resource.Resource.usage","title":"<code>usage(duration=None)</code>","text":"<p>Return the usage of the resource in the duration.</p> <p>Parameters:</p> Name Type Description Default <code>duration</code> <code>int | float | Callable | None</code> <p>the duration to trace back in time. Defaults to None.</p> <code>None</code> Source code in <code>Akatosh\\resource.py</code> <pre><code>def usage(self, duration: int | float | Callable | None = None):\n\"\"\"Return the usage of the resource in the duration.\n    Args:\n        duration (int | float | Callable | None, optional): the duration to trace back in time. Defaults to None.\n    \"\"\"        \nif duration:\nif callable(duration):\nafter = Mundus.now - duration()\nelse:\nafter = Mundus.now - duration\nif after &lt; 0:\nafter = 0\nusage_records = [\nusage_record\nfor usage_record in self.usage_records\nif usage_record[0] &gt;= after\n]\nif len(usage_records) == 0:\nreturn 1 - (self.amount / self.capacity)\nelse:\nif usage_records[-1][0] - after == 0:\nreturn 1 - (usage_records[-1][1] / self.capacity)\nelse:\nweighted_overall_amount = 0\nfor index, record in enumerate(usage_records):\nif index == 0:\nweighted_overall_amount += record[1] * (record[0] - after)\nelif index == len(usage_records) - 1:\nweighted_overall_amount += record[1] * (\nMundus.now - usage_records[index - 1][0]\n)\nelse:\nweighted_overall_amount += record[1] * (\nrecord[0] - usage_records[index - 1][0]\n)\nreturn 1 - (\nweighted_overall_amount / (usage_records[-1][0] - after)\n)\nelse:\nreturn 1 - (self.amount / self.capacity)\n</code></pre>"},{"location":"api/universe/","title":"Universe","text":""},{"location":"api/universe/#Akatosh.universe.Universe","title":"<code>Universe</code>","text":"Source code in <code>Akatosh\\universe.py</code> <pre><code>class Universe:\ndef __init__(self) -&gt; None:\n\"\"\"The Simulation Universe.\"\"\"\nself._resolution = (\n1  # the resolution of the time. 1 means minimum time unit is 0.1 second.\n)\nself._now: int | float = 0  # the current time of the simulated universe.\nself._future_events: List[Event] = list()  # the future events queue.\nself._current_events: List[Event] = list()  # the current events queue.\nself._past_events: List[Event] = list()  # the past events queue.\nself._alduin: bool = False  # trigger to stop the simulation.\nself.set_logger(logging.ERROR)  # set the default logger level to ERROR.\nasync def akatosh(self, till: int | float | None = None):\n\"\"\"Akatosh is the god of time in the Elder Scrolls universe. This method is the core of the simulation.\n        Args:\n            till (int | float | None, optional): the end time of the simulated universe. Defaults to None.\n        Raises:\n            RuntimeError: raise if the event is in unknown state or being placed in wrong event queue.\n        \"\"\"\nwhile len(self.future_events) != 0:\nif self.alduin:\nreturn\nif self.now &lt; min(event.at for event in self.future_events):\nactive_event = [\nevent for event in self.future_events if event.state == State.ACTIVE\n]\nif len(active_event) == 0:\nreturn\nelse:\nself._now = min(event.at for event in active_event)\nif till is not None:\nif self.now &gt; till:\nreturn\nlogger.debug(f\"Time: {self.now}\")\nlogger.debug(\nf\"Future events: {[(event.at, event.label) for event in self.future_events]}\"\n)\nfor event in self.future_events[:]:\nif event.at == self.now:\nif event.state == State.ACTIVE or event.state == State.INACTIVE:\nlogger.debug(f\"Event {event.label} is triggered.\")\nself.future_events.remove(event)\nself.current_events.append(event)\nelif event.state == State.CANCELED:\nlogger.debug(f\"Event {event.label} is canceled.\")\nself.future_events.remove(event)\nself.past_events.append(event)\nevent.state = State.ENDED\nelif event.state == State.ENDED:\nraise RuntimeError(\nf\"Event {event.label} is ended but inside future events queue.\"\n)\nelse:\nraise RuntimeError(f\"Event {event.label} is in unknown state.\")\nlogger.debug(\nf\"Current events: {[event.label for event in self.current_events]}\"\n)\nwhile (\nlen(\n[\nevent\nfor event in self.current_events\nif event.state == State.ACTIVE\n]\n)\n!= 0\n):\npriority = min(\nevent.priority\nfor event in self.current_events\nif event.state == State.ACTIVE\n)\nlogger.debug(\nf\"Current Priority: {priority}, {[(event.label, event.priority) for event in self.current_events]}\"\n)\nawait asyncio.gather(\n*[\nevent._perform()\nfor event in self.current_events\nif event.priority == priority\n]\n)\ndef simulate(self, till: int | float | None = None):\n\"\"\"Start the simulation.\"\"\"\nasyncio.run(self.akatosh(till))\ndef set_logger(self, level: int):\n\"\"\"Set the logger level.\"\"\"\nlogger.setLevel(level)\n@property\ndef resolution(self) -&gt; int:\n\"\"\"Return  the resolution of the time.\"\"\"\nreturn self._resolution\n@property\ndef now(self) -&gt; int | float:\n\"\"\"Return the current time of the simulated universe.\"\"\"\nreturn self._now\n@property\ndef future_events(self) -&gt; List[Event]:\n\"\"\"Return the future events queue.\"\"\"\nreturn self._future_events\n@property\ndef current_events(self) -&gt; List[Event]:\n\"\"\"Return the current events queue.\"\"\"\nreturn self._current_events\n@property\ndef past_events(self) -&gt; List[Event]:\n\"\"\"Return the past events queue.\"\"\"\nreturn self._past_events\n@property\ndef alduin(self) -&gt; bool:\n\"\"\"Return the trigger to stop the simulation.\"\"\"\nreturn self._alduin\n@alduin.setter\ndef alduin(self, value: bool):\n\"\"\"Set the trigger to stop the simulation.\"\"\"\nself._alduin = value\n</code></pre>"},{"location":"api/universe/#Akatosh.universe.Universe.alduin","title":"<code>alduin: bool</code>  <code>writable</code> <code>property</code>","text":"<p>Return the trigger to stop the simulation.</p>"},{"location":"api/universe/#Akatosh.universe.Universe.current_events","title":"<code>current_events: List[Event]</code>  <code>property</code>","text":"<p>Return the current events queue.</p>"},{"location":"api/universe/#Akatosh.universe.Universe.future_events","title":"<code>future_events: List[Event]</code>  <code>property</code>","text":"<p>Return the future events queue.</p>"},{"location":"api/universe/#Akatosh.universe.Universe.now","title":"<code>now: int | float</code>  <code>property</code>","text":"<p>Return the current time of the simulated universe.</p>"},{"location":"api/universe/#Akatosh.universe.Universe.past_events","title":"<code>past_events: List[Event]</code>  <code>property</code>","text":"<p>Return the past events queue.</p>"},{"location":"api/universe/#Akatosh.universe.Universe.resolution","title":"<code>resolution: int</code>  <code>property</code>","text":"<p>Return  the resolution of the time.</p>"},{"location":"api/universe/#Akatosh.universe.Universe.__init__","title":"<code>__init__()</code>","text":"<p>The Simulation Universe.</p> Source code in <code>Akatosh\\universe.py</code> <pre><code>def __init__(self) -&gt; None:\n\"\"\"The Simulation Universe.\"\"\"\nself._resolution = (\n1  # the resolution of the time. 1 means minimum time unit is 0.1 second.\n)\nself._now: int | float = 0  # the current time of the simulated universe.\nself._future_events: List[Event] = list()  # the future events queue.\nself._current_events: List[Event] = list()  # the current events queue.\nself._past_events: List[Event] = list()  # the past events queue.\nself._alduin: bool = False  # trigger to stop the simulation.\nself.set_logger(logging.ERROR)  # set the default logger level to ERROR.\n</code></pre>"},{"location":"api/universe/#Akatosh.universe.Universe.akatosh","title":"<code>akatosh(till=None)</code>  <code>async</code>","text":"<p>Akatosh is the god of time in the Elder Scrolls universe. This method is the core of the simulation.</p> <p>Parameters:</p> Name Type Description Default <code>till</code> <code>int | float | None</code> <p>the end time of the simulated universe. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>raise if the event is in unknown state or being placed in wrong event queue.</p> Source code in <code>Akatosh\\universe.py</code> <pre><code>async def akatosh(self, till: int | float | None = None):\n\"\"\"Akatosh is the god of time in the Elder Scrolls universe. This method is the core of the simulation.\n    Args:\n        till (int | float | None, optional): the end time of the simulated universe. Defaults to None.\n    Raises:\n        RuntimeError: raise if the event is in unknown state or being placed in wrong event queue.\n    \"\"\"\nwhile len(self.future_events) != 0:\nif self.alduin:\nreturn\nif self.now &lt; min(event.at for event in self.future_events):\nactive_event = [\nevent for event in self.future_events if event.state == State.ACTIVE\n]\nif len(active_event) == 0:\nreturn\nelse:\nself._now = min(event.at for event in active_event)\nif till is not None:\nif self.now &gt; till:\nreturn\nlogger.debug(f\"Time: {self.now}\")\nlogger.debug(\nf\"Future events: {[(event.at, event.label) for event in self.future_events]}\"\n)\nfor event in self.future_events[:]:\nif event.at == self.now:\nif event.state == State.ACTIVE or event.state == State.INACTIVE:\nlogger.debug(f\"Event {event.label} is triggered.\")\nself.future_events.remove(event)\nself.current_events.append(event)\nelif event.state == State.CANCELED:\nlogger.debug(f\"Event {event.label} is canceled.\")\nself.future_events.remove(event)\nself.past_events.append(event)\nevent.state = State.ENDED\nelif event.state == State.ENDED:\nraise RuntimeError(\nf\"Event {event.label} is ended but inside future events queue.\"\n)\nelse:\nraise RuntimeError(f\"Event {event.label} is in unknown state.\")\nlogger.debug(\nf\"Current events: {[event.label for event in self.current_events]}\"\n)\nwhile (\nlen(\n[\nevent\nfor event in self.current_events\nif event.state == State.ACTIVE\n]\n)\n!= 0\n):\npriority = min(\nevent.priority\nfor event in self.current_events\nif event.state == State.ACTIVE\n)\nlogger.debug(\nf\"Current Priority: {priority}, {[(event.label, event.priority) for event in self.current_events]}\"\n)\nawait asyncio.gather(\n*[\nevent._perform()\nfor event in self.current_events\nif event.priority == priority\n]\n)\n</code></pre>"},{"location":"api/universe/#Akatosh.universe.Universe.set_logger","title":"<code>set_logger(level)</code>","text":"<p>Set the logger level.</p> Source code in <code>Akatosh\\universe.py</code> <pre><code>def set_logger(self, level: int):\n\"\"\"Set the logger level.\"\"\"\nlogger.setLevel(level)\n</code></pre>"},{"location":"api/universe/#Akatosh.universe.Universe.simulate","title":"<code>simulate(till=None)</code>","text":"<p>Start the simulation.</p> Source code in <code>Akatosh\\universe.py</code> <pre><code>def simulate(self, till: int | float | None = None):\n\"\"\"Start the simulation.\"\"\"\nasyncio.run(self.akatosh(till))\n</code></pre>"},{"location":"examples/cancel_event/","title":"Cancel Event","text":"<pre><code>import logging\nfrom Akatosh import InstantEvent, event, Mundus\n# define the event function\ndef hellow_world():\nprint(f\"{Mundus.now}:\\tHello World!\")\n# create a event occurs at 5s\nlater_event = InstantEvent(at=5, action=hellow_world)\n# create a event  occurs at 3s to cancel the above event at 5s\n@event(at=3, label=\"cancel\")\ndef resume():\nprint(f\"{Mundus.now}:\\tCancel future event.\")\nlater_event.cancel()\n# enable debug message\nMundus.set_logger(logging.DEBUG)\n# run the simulation\nMundus.simulate()\n</code></pre>"},{"location":"examples/continuous_event/","title":"Continuous Event","text":"<pre><code>import random\nfrom Akatosh import ContinuousEvent, Mundus\nimport logging\n# define the actual function for continuous event\ndef action():\nprint(f\"Hello World at {Mundus.now}\")\n# create the continuous event\nevent = ContinuousEvent(at=0, interval=random.random(), duration=10, action=action)\nMundus.set_logger(logging.DEBUG)\nMundus.simulate()\n</code></pre>"},{"location":"examples/create_event_within_event/","title":"Create Event within Event","text":"<pre><code>import logging\nfrom Akatosh import event, Mundus\n# create a instant event at simulation time 1.0s\n@event(at=1)\ndef hellow_world():\nprint(f\"{Mundus.now}:\\tHello World!\")\n# this instant event create anothe instant event at simulation time 5.0s\n@event(at=5)\ndef hellow_world_again():\nprint(f\"{Mundus.now}:\\tHello World! Again!\")\n# enable debug message\nMundus.set_logger(logging.DEBUG)\n# simulate\nMundus.simulate()\n</code></pre>"},{"location":"examples/entity/","title":"Entity","text":"<pre><code>import logging\nfrom Akatosh import Entity, Mundus, Resource, event\n# define a simple test enity\nclass TestEntity(Entity):\n# implement the callback function upon creation\ndef on_creation(self):\nprint(f\"Entity {self.label} created\")\n# implement the callback function upon termination\ndef on_termination(self):\nprint(f\"Entity {self.label} terminated\")\n# create the test entity\ntest_entity = TestEntity(label=\"Test Entity\", create_at=0, terminate_at=10)\n# create a simple resource\ntest_resource = Resource(label=\"Test Resource\", capacity=1)\n# create a simple  instant event to occupy the resource\n@event(at=2, label=\"Test Event Get Resource\")\ndef test_event():\ntest_entity.get(test_resource, 1)\n# enable debug message\nMundus.set_logger(logging.DEBUG)\n# run the simulation\nMundus.simulate()\n</code></pre>"},{"location":"examples/event_priority/","title":"Event Priority","text":"<pre><code>import logging\nfrom Akatosh import event, Mundus\n# create a event with priority 2\n@event(at=0, priority=2, label=\"AuPost\")\ndef au_post():\nprint(f\"{Mundus.now}:\\tAuPost deliver!\")\n# create a event with priority 1\n@event(at=0, priority=1, label=\"StarTrek\")\ndef star_trek():\nprint(f\"{Mundus.now}:\\tStar Trek deliver!\")\nMundus.set_logger(logging.DEBUG)\nMundus.simulate()\n# the Star Trek will deliver first, AuPost sucks!\n</code></pre>"},{"location":"examples/event_wait_event/","title":"Event After Another Event","text":"<pre><code>import logging\nfrom Akatosh import event, Mundus, InstantEvent\n# define the actual function of the event\ndef hellow_world():\nprint(f\"{Mundus.now}:\\tHello World!\")\n# create a instant event at simulation time 5s\ne = InstantEvent(at=5, action=hellow_world, label=\"Hello World\")\n# create a instant event at simulation time 1s, but set the above event as precursor. \n# So this event will be triggered at 1s but not executed until above event is done.\n@event(at=0, precursor=e, label=\"Hello World Again\")\nasync def hellow_world_again():\nprint(f\"{Mundus.now}:\\tHello World! Again!\")\n# enable debug message\nMundus.set_logger(logging.DEBUG)\n# run the simulate\nMundus.simulate()\n</code></pre>"},{"location":"examples/instant_event/","title":"Instant Event","text":"<pre><code>import logging\nfrom Akatosh import event, Mundus\n# create an instant event at simulation time 5.0s, print \"Hello World Again!\"\n@event(at=5)\ndef hellow_world_again():\nprint(f\"{Mundus.now}:\\tHello World! Again!\")\n# create an instant event at simulation time 1.0s, print \"Hello World!\"\n@event(at=1)\ndef hellow_world():\nprint(f\"{Mundus.now}:\\tHello World!\")\n# enable debug message\nMundus.set_logger(logging.DEBUG)\n# simulate\nMundus.simulate()\n</code></pre>"},{"location":"examples/pause_event/","title":"Pause Event","text":"<pre><code>import logging\nfrom Akatosh import InstantEvent, event, Mundus\n# create a event that should occur at 5.0s\ndef hellow_world():\nprint(f\"{Mundus.now}:\\tHello World!\")\nlater_event = InstantEvent(at=5, action=hellow_world)\n# create a event to resume the later event.\n@event(at=3, label=\"resume\")\ndef resume():\nprint(f\"{Mundus.now}:\\tResume the future event.\")\nlater_event.activate()\n# create a event to pause the \"later_event\"\n@event(at=0, label=\"pause\")\ndef pause():\nprint(f\"{Mundus.now}:\\tPause the future event.\")\nlater_event.deactivate()\n# enable debug message\nMundus.set_logger(logging.DEBUG)\n# run the simulation\nMundus.simulate()\n</code></pre>"},{"location":"examples/resource/","title":"Resource","text":"<pre><code>from Akatosh import Resource, event, Mundus\n# create a resource with capacity 100\nres = Resource(100, label=\"test\")\nfor i in range(10):\n# get 10 units per second for 10s\n@event(at=i, label=f\"consumer{i}\")\ndef consumer():\nres.get(10)\nprint(f\"{Mundus.now} get {res.amount}, current usage {res.usage()}\")\nfor i in range(5):\n# put 10 units per second for first 5s\n@event(at=i, label=f\"producer{i}\")\ndef consumer():\nres.put(10)\nprint(f\"{Mundus.now} put {res.amount}, current usage {res.usage()}\")\nfor i in range(10):\n# report the usage every second for 10s, tracing back for 2s\n@event(at=i, label=f\"producer{i}\")\ndef consumer():\nprint(f\"{Mundus.now} past 2s usage {res.usage(2)}\")\n# run the simulation\nMundus.simulate()\n</code></pre>"}]}